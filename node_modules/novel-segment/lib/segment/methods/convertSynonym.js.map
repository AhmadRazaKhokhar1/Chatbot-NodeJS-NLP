{"version":3,"file":"convertSynonym.js","sourceRoot":"","sources":["convertSynonym.ts"],"names":[],"mappings":";;;;AAAA,uEAA4C;AAC5C,4CAA0D;AAoC1D,SAAgB,cAAc,CAAC,GAAiB,EAAE,OAAiB;IAElE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,YAAY,EAAE,UAAU,EAAE,GAAG,OAAO,CAAC;IAEhE,IAAI,WAAW,GAAG,CAAC,CAAC;IAEpB,gCAAgC;IAEhC,QAAQ;IACR,SAAS,eAAe,CAAC,IAAkB;QAE1C,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,IAAgB;YAE/C,IAAI,IAAa,CAAC;YAClB,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;YACf,IAAI,EAAU,CAAC;YAEf,IAAI,KAAK,GAAG,IAAA,kBAAU,EAAC,IAAI,CAAC,CAAC;YAE7B,IAAI,CAAC,IAAI,YAAY,EACrB,CAAC;gBACA,IAAI,GAAG,IAAI,CAAC;gBACZ,EAAE,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;YACtB,CAAC;iBACI,IAAI,KAAK,CAAC,UAAU,IAAI,CAAC,KAAK,CAAC,cAAc,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,MAAM,EACzF,CAAC;gBACA,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAW,EAAE,CAAC;oBAE1C,IAAI,OAAO,CAAC,KAAK,QAAQ,EACzB,CAAC;wBACA,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACX,CAAC;yBACI,IAAI,CAAC,CAAC,CAAC,IAAI,YAAY,EAC5B,CAAC;wBACA,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBAC1B,IAAI,GAAG,IAAI,CAAC;oBACb,CAAC;yBAED,CAAC;wBACA,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACb,CAAC;oBAED,OAAO,CAAC,CAAC;gBACV,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACjB,CAAC;YAED,IAAI,IAAI,EACR,CAAC;gBACA,KAAK,EAAE,CAAC;gBACR,WAAW,EAAE,CAAC;gBACd,gDAAgD;gBAEhD,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;gBAEf,IAAI,CAAC,IAAI,UAAU,EACnB,CAAC;oBACA,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;gBAC1B,CAAC;gBAED,IAAI,CAAC,GAAG,MAAM,CAAC,GAAG,EAClB,CAAC;oBACA,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC;gBACpB,CAAC;gBAED,IAAI,QAAQ,GAAG,IAAA,kBAAU,EAAC;oBACzB,GAAG,IAAI;oBAEP,CAAC,EAAE,EAAE;oBACL,EAAE,EAAE,CAAC;oBACL,CAAC;oBACD,EAAE,EAAE,IAAI,CAAC,CAAC;oBAEV,cAAc;oBAEd,eAAe;iBACf,EAAE;oBACF,cAAc,EAAE,IAAI;oBACpB,gBAAgB;oBAEhB;;;uBAGG;oBACH,OAAO,EAAE,IAAA,cAAS,EAAC,EAAE,EAAE,IAAI,CAAe;iBAE1C,EAAE,IAAI,CAAC,CAAC;gBAET,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAClB,CAAC;iBAED,CAAC;gBACA,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACd,CAAC;YAED,KAAK,GAAG,SAAS,CAAC;YAElB,OAAO,CAAC,CAAC;QACV,CAAC,EAAE,EAAkB,CAAC,CAAC;QACvB,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAkC,CAAC;IACrE,CAAC;IAED,IAAI,MAAoC,CAAC;IACzC,GACA,CAAC;QACA,MAAM,GAAG,eAAe,CAAC,GAAG,CAAC,CAAC;QAC9B,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC;QAElB,MAAM,CAAC,IAAI,GAAG,SAAS,CAAC;IACzB,CAAC,QACM,MAAM,CAAC,KAAK,GAAG,CAAC,EAAE;IAEzB,MAAM,GAAG,SAAS,CAAC;IAEnB,IAAI,SAAS,EACb,CAAC;QACA,OAAO,EAAE,KAAK,EAAE,WAAW,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC;IAC1C,CAAC;IAED,OAAO,GAAG,CAAC;AACZ,CAAC;AAxHD,wCAwHC","sourcesContent":["import deepmerge from 'deepmerge-plus/core';\nimport { debugToken, IWordDebug } from '../../util/debug';\nimport { IDICT, IDICT_SYNONYM } from '../types';\nimport { ITSOverwrite } from 'ts-type';\nimport { POSTAG } from '@novel-segment/postag/lib/postag/ids';\nimport { IWord } from '@novel-segment/types';\n\ninterface IOptions\n{\n\t/**\n\t * for debug\n\t */\n\tshowcount?: boolean,\n\tDICT_SYNONYM: IDICT_SYNONYM,\n\tDICT_TABLE: IDICT<IWord>,\n\tPOSTAG: typeof POSTAG,\n}\n\nexport interface IConvertSynonymWithShowcount\n{\n\tcount: number,\n\tlist: IWordDebug[],\n}\n\n/**\n * 转换同义词\n */\nexport function convertSynonym(ret: IWordDebug[], options: ITSOverwrite<IOptions, {\n\tshowcount: true,\n}>): {\n\tcount: number,\n\tlist: IWordDebug[],\n}\n/**\n * 转换同义词\n */\nexport function convertSynonym(ret: IWordDebug[], options?: IOptions): IWordDebug[]\nexport function convertSynonym(ret: IWordDebug[], options: IOptions)\n{\n\tconst { showcount, POSTAG, DICT_SYNONYM, DICT_TABLE } = options;\n\n\tlet total_count = 0;\n\n\t//const RAW = Symbol.for('RAW');\n\n\t// 转换同义词\n\tfunction _convertSynonym(list: IWordDebug[])\n\t{\n\t\tlet count = 0;\n\t\tlist = list.reduce(function (a, item: IWordDebug)\n\t\t{\n\t\t\tlet bool: boolean;\n\t\t\tlet w = item.w;\n\t\t\tlet nw: string;\n\n\t\t\tlet debug = debugToken(item);\n\n\t\t\tif (w in DICT_SYNONYM)\n\t\t\t{\n\t\t\t\tbool = true;\n\t\t\t\tnw = DICT_SYNONYM[w];\n\t\t\t}\n\t\t\telse if (debug.autoCreate && !debug.convertSynonym && !item.ow && item.m && item.m.length)\n\t\t\t{\n\t\t\t\tnw = item.m.reduce(function (a: string[], b)\n\t\t\t\t{\n\t\t\t\t\tif (typeof b === 'string')\n\t\t\t\t\t{\n\t\t\t\t\t\ta.push(b);\n\t\t\t\t\t}\n\t\t\t\t\telse if (b.w in DICT_SYNONYM)\n\t\t\t\t\t{\n\t\t\t\t\t\ta.push(DICT_SYNONYM[b.w]);\n\t\t\t\t\t\tbool = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ta.push(b.w);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn a;\n\t\t\t\t}, []).join('');\n\t\t\t}\n\n\t\t\tif (bool)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\ttotal_count++;\n\t\t\t\t//return { w: DICT_SYNONYM[item.w], p: item.p };\n\n\t\t\t\tlet p = item.p;\n\n\t\t\t\tif (w in DICT_TABLE)\n\t\t\t\t{\n\t\t\t\t\tp = DICT_TABLE[w].p || p;\n\t\t\t\t}\n\n\t\t\t\tif (p & POSTAG.BAD)\n\t\t\t\t{\n\t\t\t\t\tp = p ^ POSTAG.BAD;\n\t\t\t\t}\n\n\t\t\t\tlet item_new = debugToken({\n\t\t\t\t\t...item,\n\n\t\t\t\t\tw: nw,\n\t\t\t\t\tow: w,\n\t\t\t\t\tp,\n\t\t\t\t\top: item.p,\n\n\t\t\t\t\t//[RAW]: item,\n\n\t\t\t\t\t//source: item,\n\t\t\t\t}, {\n\t\t\t\t\tconvertSynonym: true,\n\t\t\t\t\t//_source: item,\n\n\t\t\t\t\t/**\n\t\t\t\t\t * JSON.stringify\n\t\t\t\t\t * avoid TypeError: Converting circular structure to JSON\n\t\t\t\t\t */\n\t\t\t\t\t_source: deepmerge({}, item) as IWordDebug,\n\n\t\t\t\t}, true);\n\n\t\t\t\ta.push(item_new);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta.push(item);\n\t\t\t}\n\n\t\t\tdebug = undefined;\n\n\t\t\treturn a;\n\t\t}, [] as IWordDebug[]);\n\t\treturn { count: count, list: list } as IConvertSynonymWithShowcount;\n\t}\n\n\tlet result: IConvertSynonymWithShowcount;\n\tdo\n\t{\n\t\tresult = _convertSynonym(ret);\n\t\tret = result.list;\n\n\t\tresult.list = undefined;\n\t}\n\twhile (result.count > 0);\n\n\tresult = undefined;\n\n\tif (showcount)\n\t{\n\t\treturn { count: total_count, list: ret };\n\t}\n\n\treturn ret;\n}\n"]}