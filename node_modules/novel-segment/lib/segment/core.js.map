{"version":3,"file":"core.js","sourceRoot":"","sources":["core.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * 分词器接口\n *\n * @author 老雷<leizongmin@gmail.com>\n */\n\nimport { TableDictBlacklist } from '@novel-segment/table-blacklist';\nimport { AbstractTableDictCore } from '@novel-segment/table-core-abstract';\nimport { TableDict } from '@novel-segment/table-dict';\nimport { TableDictStopword } from '@novel-segment/table-stopword';\nimport { TableDictSynonym } from '@novel-segment/table-synonym';\nimport { ISubOptimizer, ISubTokenizer, Optimizer, Tokenizer } from '../mod/index';\nimport { IWordDebug } from '../util/index';\nimport {\n\tIDICT,\n\tIDICT2,\n\tIDICT_BLACKLIST,\n\tIDICT_STOPWORD,\n\tIDICT_SYNONYM,\n\tIOptionsDoSegment,\n\tIOptionsSegment,\n\tISPLIT,\n\tISPLIT_FILTER,\n} from './types';\nimport { split } from './methods/split';\nimport { indexOf } from './methods/indexOf';\nimport { convertSynonym, IConvertSynonymWithShowcount } from './methods/convertSynonym';\nimport { listModules } from './methods/listModules';\nimport { _get_text } from './methods/_get_text';\nimport { getOptionsDoSegment } from './methods/getOptionsDoSegment';\nimport { useModules } from './methods/useModules';\nimport {\n\t_doSegmentSimple,\n\t_doSegmentStripPOSTAG,\n\t_doSegmentStripSpace,\n\t_doSegmentStripStopword,\n} from './methods/doSegment';\nimport { ITSTypeAndStringLiteral } from 'ts-type/lib/helper/string';\nimport { ITSOverwrite, ITSPartialRecord } from 'ts-type/lib/type/record';\nimport { POSTAG } from '@novel-segment/postag/lib/postag/ids';\nimport { EnumDictDatabase, IWord } from '@novel-segment/types';\nimport { stringify } from '@novel-segment/stringify';\n\n/**\n * 创建分词器接口\n */\nexport class SegmentCore\n{\n\n\t/**\n\t * 分段\n\t *\n\t * 由於 segment 是利用對內容的前後文分析來進行分詞\n\t * 所以如何切割段落對於結果就會產生不同影響\n\t *\n\t * `RegExp` or 具有 `.[Symbol.split](input: string, limit?: number) => string[]` 的物件\n\t *\n\t * @type {Segment.ISPLIT}\n\t */\n\tSPLIT: ISPLIT = /([\\r\\n]+|^[　\\s]+|[　\\s]+$|[　\\s]{2,})/gm as ISPLIT;\n\n\t/**\n\t * 分段之後 如果符合以下條件 則直接忽略分析\n\t * `RegExp` or 具有 `.test(input: string) => boolean` 的物件\n\t *\n\t * @type {Segment.ISPLIT_FILTER}\n\t */\n\tSPLIT_FILTER: ISPLIT_FILTER = /^([\\r\\n]+)$/g as ISPLIT_FILTER;\n\n\t/**\n\t * 词性\n\t * @type {POSTAG}\n\t */\n\tPOSTAG = POSTAG;\n\t/**\n\t * 词典表\n\t * @type {{}}\n\t */\n\tDICT: {\n\t\tSTOPWORD?: IDICT_STOPWORD,\n\t\tSYNONYM?: IDICT_SYNONYM,\n\n\t\t[key: string]: IDICT,\n\t} & ITSPartialRecord<ITSTypeAndStringLiteral<EnumDictDatabase.SYNONYM>, IDICT_SYNONYM> & ITSPartialRecord<ITSTypeAndStringLiteral<EnumDictDatabase.STOPWORD>, IDICT_STOPWORD> = {};\n\tmodules = {\n\t\t/**\n\t\t * 分词模块\n\t\t */\n\t\ttokenizer: [],\n\t\t/**\n\t\t * 优化模块\n\t\t */\n\t\toptimizer: [],\n\t} as {\n\t\ttokenizer: ISubTokenizer[],\n\t\toptimizer: ISubOptimizer[],\n\t};\n\n\ttokenizer: Tokenizer;\n\toptimizer: Optimizer;\n\n\tdb: {\n\t\t[key: string]: TableDict,\n\t} = {};\n\n\toptions: IOptionsSegment = {};\n\n\tinited?: boolean;\n\n\tconstructor(options: IOptionsSegment = {})\n\t{\n\t\tconst self = this;\n\n\t\tthis.options = Object.assign({}, this.options, options);\n\n\t\tthis.tokenizer = new Tokenizer(this as any);\n\t\tthis.optimizer = new Optimizer(this as any);\n\n\t\tif (this.options.db)\n\t\t{\n\t\t\tthis.options.db.forEach(function (data)\n\t\t\t{\n\t\t\t\tself.db[data.type] = data;\n\t\t\t});\n\t\t}\n\n\t\tdelete this.options.db;\n\t}\n\n\tgetDictDatabase<R extends TableDictSynonym>(type: EnumDictDatabase.SYNONYM,\n\t\tautocreate?: boolean,\n\t\tlibTableDict?: { new(...argv): R },\n\t): R\n\tgetDictDatabase<R extends TableDict>(type: EnumDictDatabase.TABLE, autocreate?: boolean, libTableDict?: { new(...argv): R }): R\n\tgetDictDatabase<R extends TableDictStopword>(type: EnumDictDatabase.STOPWORD,\n\t\tautocreate?: boolean,\n\t\tlibTableDict?: { new(...argv): R },\n\t): R\n\tgetDictDatabase<R extends TableDictBlacklist>(type: EnumDictDatabase.BLACKLIST,\n\t\tautocreate?: boolean,\n\t\tlibTableDict?: { new(...argv): R },\n\t): R\n\tgetDictDatabase<R extends TableDictBlacklist>(type: EnumDictDatabase.BLACKLIST_FOR_OPTIMIZER,\n\t\tautocreate?: boolean,\n\t\tlibTableDict?: { new(...argv): R },\n\t): R\n\tgetDictDatabase<R extends AbstractTableDictCore<any>>(type: string | EnumDictDatabase,\n\t\tautocreate?: boolean,\n\t\tlibTableDict?: { new(...argv): R },\n\t): R\n\tgetDictDatabase(type: string, autocreate?: boolean, libTableDict?)\n\t{\n\t\t// @ts-ignore\n\t\treturn this.db[type];\n\t}\n\n\t/**\n\t * 载入分词模块\n\t *\n\t * @param {String|Array|Object} module 模块名称(数组)或模块对象\n\t * @return {Segment}\n\t */\n\tuse(mod: ISubOptimizer, ...argv): this\n\tuse(mod: ISubTokenizer, ...argv): this\n\tuse(mod, ...argv): this\n\tuse(mod, ...argv)\n\t{\n\t\tuseModules(this, mod, ...argv);\n\n\t\treturn this\n\t}\n\n\t/**\n\t * 取词典表\n\t *\n\t * @param {String} type 类型\n\t * @return {object}\n\t */\n\tgetDict(type: ITSTypeAndStringLiteral<EnumDictDatabase.STOPWORD>): IDICT_STOPWORD\n\tgetDict(type: ITSTypeAndStringLiteral<EnumDictDatabase.SYNONYM>): IDICT_SYNONYM\n\tgetDict(type: ITSTypeAndStringLiteral<EnumDictDatabase.TABLE>): IDICT<IWord>\n\tgetDict(type: ITSTypeAndStringLiteral<EnumDictDatabase.BLACKLIST>): IDICT_BLACKLIST\n\tgetDict(type: ITSTypeAndStringLiteral<EnumDictDatabase.BLACKLIST_FOR_OPTIMIZER>): IDICT_BLACKLIST\n\tgetDict(type: 'TABLE2'): IDICT2<IWord>\n\tgetDict(type: ITSTypeAndStringLiteral<EnumDictDatabase>): IDICT\n\tgetDict(type: unknown): IDICT\n\tgetDict(type)\n\t{\n\t\treturn this.DICT[type];\n\t}\n\n\tgetOptionsDoSegment<T extends IOptionsDoSegment>(options?: T): T\n\t{\n\t\treturn getOptionsDoSegment<T>(options, this.options.optionsDoSegment)\n\t}\n\n\tprotected _get_text(text: string | Buffer): string\n\t{\n\t\treturn _get_text(text)\n\t}\n\n\taddBlacklist(word: string, remove?: boolean)\n\t{\n\t\tlet me = this;\n\n\t\tconst BLACKLIST = me.getDictDatabase(EnumDictDatabase.BLACKLIST);\n\t\tconst TABLE = me.getDictDatabase(EnumDictDatabase.TABLE);\n\n\t\tlet bool = !remove;\n\n\t\tif (bool)\n\t\t{\n\t\t\tBLACKLIST.add(word);\n\t\t\tTABLE.remove(word);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBLACKLIST.remove(word)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * remove key in TABLE by BLACKLIST\n\t */\n\tdoBlacklist()\n\t{\n\t\tlet me = this;\n\n\t\tconst BLACKLIST = me.getDict(EnumDictDatabase.BLACKLIST);\n\t\tconst TABLE = me.getDictDatabase(EnumDictDatabase.TABLE);\n\n\t\tObject.entries(BLACKLIST)\n\t\t\t.forEach(function ([key, bool])\n\t\t\t{\n\t\t\t\tbool && TABLE.remove(key)\n\t\t\t})\n\t\t;\n\n\t\treturn this\n\t}\n\n\tlistModules(options: IOptionsDoSegment = {})\n\t{\n\t\toptions = this.getOptionsDoSegment(options);\n\n\t\treturn listModules(this.modules, options);\n\t}\n\n\t/**\n\t * 开始分词\n\t *\n\t * @param {String} text 文本\n\t * @param {Object} options 选项\n\t *   - {Boolean} simple 是否仅返回单词内容\n\t *   - {Boolean} stripPunctuation 去除标点符号\n\t *   - {Boolean} convertSynonym 转换同义词\n\t *   - {Boolean} stripStopword 去除停止符\n\t * @return {Array}\n\t */\n\tdoSegment(text: string | Buffer, options: ITSOverwrite<IOptionsDoSegment, {\n\t\tsimple: true,\n\t}>): string[]\n\tdoSegment(text: string | Buffer, options?: IOptionsDoSegment): IWord[]\n\tdoSegment(text, options: IOptionsDoSegment = {})\n\t{\n\t\tconst me = this;\n\n\t\toptions = me.getOptionsDoSegment(options);\n\n\t\t//console.dir(options);\n\n\t\tlet text_list = me._get_text(text)\n\t\t\t// @ts-ignore\n\t\t\t.split(this.SPLIT)\n\t\t;\n\t\ttext = undefined;\n\n\t\tconst mods = me.listModules(options).enable;\n\n\t\t// 将文本按照换行符分割成多段，并逐一分词\n\t\tlet ret = text_list.reduce(function (ret, section)\n\t\t{\n\t\t\t//console.dir(section);\n\n\t\t\tif (me.SPLIT_FILTER.test(section))\n\t\t\t{\n\t\t\t\tret = ret.concat({ w: section });\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tsection = [];\n\t\t\t}\n\n\t\t\t//section = section.trim();\n\t\t\tif (section.length > 0)\n\t\t\t{\n\t\t\t\t// 分词\n\t\t\t\tlet sret = me.tokenizer.split(section, mods.tokenizer);\n\n\t\t\t\t// 优化\n\t\t\t\tsret = me.optimizer.doOptimize(sret, mods.optimizer);\n\n\t\t\t\t// 连接分词结果\n\t\t\t\tif (sret.length > 0)\n\t\t\t\t{\n\t\t\t\t\tret = ret.concat(sret);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}, []);\n\n\t\t// 去除标点符号\n\t\tif (options.stripPunctuation)\n\t\t{\n\t\t\tret = _doSegmentStripPOSTAG(ret, POSTAG.D_W)\n\t\t}\n\n\t\tif (options.convertSynonym)\n\t\t{\n\t\t\tret = this.convertSynonym(ret);\n\t\t}\n\n\t\t// 去除停止符\n\t\tif (options.stripStopword)\n\t\t{\n\t\t\tret = _doSegmentStripStopword(ret, me.getDict('STOPWORD'))\n\t\t}\n\n\t\tif (options.stripSpace)\n\t\t{\n\t\t\tret = _doSegmentStripSpace(ret)\n\t\t}\n\n\t\t// 仅返回单词内容\n\t\tif (options.simple)\n\t\t{\n\t\t\tret = _doSegmentSimple(ret)\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * 转换同义词\n\t */\n\tconvertSynonym(ret: IWordDebug[], showcount: true): {\n\t\tcount: number,\n\t\tlist: IWordDebug[],\n\t}\n\t/**\n\t * 转换同义词\n\t */\n\tconvertSynonym(ret: IWordDebug[], showcount?: boolean): IWordDebug[]\n\tconvertSynonym(ret: IWordDebug[], showcount?: boolean)\n\t{\n\t\treturn convertSynonym(ret, {\n\t\t\tshowcount,\n\t\t\tDICT_SYNONYM: this.getDict(EnumDictDatabase.SYNONYM),\n\t\t\tDICT_TABLE: this.getDict(EnumDictDatabase.TABLE),\n\t\t\tPOSTAG: this.POSTAG,\n\t\t}) as IWordDebug[] | IConvertSynonymWithShowcount;\n\t}\n\n\t/**\n\t * 将单词数组连接成字符串\n\t *\n\t * @param {Array} words 单词数组\n\t * @return {String}\n\t */\n\tstringify(words: Array<IWord | string>, ...argv): string\n\t{\n\t\treturn stringify(words, ...argv);\n\t}\n\n\t/**\n\t * 将单词数组连接成字符串\n\t *\n\t * @param {Array} words 单词数组\n\t * @return {String}\n\t */\n\tstatic stringify(words: Array<IWord | string>, ...argv): string\n\t{\n\t\treturn stringify(words, ...argv)\n\t}\n\n\t/**\n\t * 根据某个单词或词性来分割单词数组\n\t *\n\t * @param {Array} words 单词数组\n\t * @param {Number|String} s 用于分割的单词或词性\n\t * @return {Array}\n\t */\n\tsplit(words: IWord[], s: string | number, ...argv): IWord[]\n\t{\n\t\treturn split(words, s, ...argv)\n\t}\n\n\t/**\n\t * 在单词数组中查找某一个单词或词性所在的位置\n\t *\n\t * @param {Array} words 单词数组\n\t * @param {Number|String} s 要查找的单词或词性\n\t * @param {Number} cur 开始位置\n\t * @return {Number} 找不到，返回-1\n\t */\n\tindexOf(words: IWord[], s: string | number, cur?: number, ...argv)\n\t{\n\t\treturn indexOf(words, cur, ...argv)\n\t}\n\n}\n\nexport { IDICT, IDICT2, IDICT_BLACKLIST, IDICT_STOPWORD, IDICT_SYNONYM, IOptionsDoSegment, IOptionsSegment, ISPLIT, ISPLIT_FILTER, IWord }\n\nexport default SegmentCore;\n"]}