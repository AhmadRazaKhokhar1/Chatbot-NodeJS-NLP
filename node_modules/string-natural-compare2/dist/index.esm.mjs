const e = {}, t = [];

function isNumberCode(e) {
  return e >= 48 && e <= 57;
}

function naturalCompare(e, r, n) {
  const a = _strLength(e, "a"), o = _strLength(r, "b");
  let u = 0, d = 0, i = t, h = 0;
  for (n && (n.caseInsensitive && (e = e.toLowerCase(), r = r.toLowerCase()), n.alphabet && (i = buildAlphabetIndexMap(n.alphabet))); u < a && d < o; ) {
    let t, n = e.charCodeAt(u), f = r.charCodeAt(d);
    if (isNumberCode(n)) {
      if (!isNumberCode(f)) return n - f;
      let i = u, l = d;
      for (;48 === n && ++i < a; ) n = e.charCodeAt(i);
      for (;48 === f && ++l < o; ) f = r.charCodeAt(l);
      i !== l && 0 === h && (h = i - l);
      let s = _indexOfNumEnd(e, a, i), p = _indexOfNumEnd(r, o, l);
      if (t = s - i - p + l, 0 !== t) return t;
      for (;i < s; ) if (t = e.charCodeAt(i++) - r.charCodeAt(l++), 0 !== t) return t;
      u = s, d = p;
    } else {
      if (0 !== (t = _alphabetCompare(n, f, i))) return t;
      ++u, ++d;
    }
  }
  return u < a ? 1 : d < o ? -1 : h;
}

function buildAlphabetIndexMap(t) {
  const r = e[t];
  if (void 0 !== r) return r;
  const n = [], a = t.split("").reduce(((e, t) => Math.max(e, t.charCodeAt(0))), 0);
  for (let e = 0; e <= a; e++) n.push(-1);
  for (let e = 0; e < t.length; e++) n[t.charCodeAt(e)] = e;
  return e[t] = n;
}

function _indexOfNumEnd(e, t, r) {
  for (;r < t && isNumberCode(e.charCodeAt(r)); ) ++r;
  return r;
}

function _alphabetCompare(e, t, r) {
  return e !== t ? e < r.length && t < r.length && -1 !== r[e] && -1 !== r[t] ? r[e] - r[t] : e - t : 0;
}

function _strLength(e, t) {
  if ("string" != typeof e) throw new TypeError(`The ${t} argument must be a string. Received type '${typeof e}'`);
  return e.length;
}

export { _alphabetCompare, _indexOfNumEnd, _strLength, buildAlphabetIndexMap, naturalCompare as default, isNumberCode, naturalCompare };
//# sourceMappingURL=index.esm.mjs.map
