{"version":3,"file":"index.esm.mjs","sources":["../src/index.ts"],"sourcesContent":["export interface IOptions\n{\n  /**\n   * Set to `true` to compare strings case-insensitively. Default: `false`.\n   * @default false\n   */\n  caseInsensitive?: boolean,\n  /**\n   * A string of characters that define a custom character ordering. Default: `undefined`.\n   */\n  alphabet?: string,\n}\n\nexport type IAlphabetIndexMap = number[];\n\nconst alphabetIndexMapCache: Record<string, IAlphabetIndexMap> = {};\nconst defaultAlphabetIndexMap: IAlphabetIndexMap = [];\n\nexport function isNumberCode(code: number) {\n  return code >= 48/* '0' */ && code <= 57/* '9' */;\n}\n\nexport function naturalCompare(a: string, b: string, opts?: IOptions) {\n  const lengthA = _strLength(a, 'a');\n  const lengthB = _strLength(b, 'b');\n  let indexA = 0;\n  let indexB = 0;\n  let alphabetIndexMap = defaultAlphabetIndexMap;\n  let firstDifferenceInLeadingZeros = 0;\n\n  if (opts) {\n    if (opts.caseInsensitive) {\n      a = a.toLowerCase();\n      b = b.toLowerCase();\n    }\n\n    if (opts.alphabet) {\n      alphabetIndexMap = buildAlphabetIndexMap(opts.alphabet);\n    }\n  }\n\n  while (indexA < lengthA && indexB < lengthB) {\n    let charCodeA = a.charCodeAt(indexA);\n    let charCodeB = b.charCodeAt(indexB);\n    let difference: number;\n\n    if (isNumberCode(charCodeA)) {\n      if (!isNumberCode(charCodeB)) {\n        return charCodeA - charCodeB;\n      }\n\n      let numStartA = indexA;\n      let numStartB = indexB;\n\n      while (charCodeA === 48/* '0' */ && ++numStartA < lengthA) {\n        charCodeA = a.charCodeAt(numStartA);\n      }\n      while (charCodeB === 48/* '0' */ && ++numStartB < lengthB) {\n        charCodeB = b.charCodeAt(numStartB);\n      }\n\n      if (numStartA !== numStartB && firstDifferenceInLeadingZeros === 0) {\n        firstDifferenceInLeadingZeros = numStartA - numStartB;\n      }\n\n      let numEndA = _indexOfNumEnd(a, lengthA, numStartA);\n      let numEndB = _indexOfNumEnd(b, lengthB, numStartB);\n\n      difference = numEndA - numStartA - numEndB + numStartB; // numA length - numB length\n      if (difference !== 0) {\n        return difference;\n      }\n\n      while (numStartA < numEndA) {\n        difference = a.charCodeAt(numStartA++) - b.charCodeAt(numStartB++);\n        if (difference !== 0) {\n          return difference;\n        }\n      }\n\n      indexA = numEndA;\n      indexB = numEndB;\n      continue;\n    }\n\n    if (0 !== (difference = _alphabetCompare(charCodeA, charCodeB, alphabetIndexMap)))\n    {\n      return difference;\n    }\n\n    ++indexA;\n    ++indexB;\n  }\n\n  if (indexA < lengthA) { // `b` is a substring of `a`\n    return 1 as const;\n  }\n\n  if (indexB < lengthB) { // `a` is a substring of `b`\n    return -1 as const;\n  }\n\n  return firstDifferenceInLeadingZeros;\n}\n\nexport function buildAlphabetIndexMap(alphabet: string): IAlphabetIndexMap {\n  const existingMap = alphabetIndexMapCache[alphabet];\n  if (existingMap !== undefined) {\n    return existingMap;\n  }\n\n  const indexMap: IAlphabetIndexMap = [];\n  const maxCharCode = alphabet.split('').reduce((maxCode, char) => {\n    return Math.max(maxCode, char.charCodeAt(0));\n  }, 0);\n\n  for (let i = 0; i <= maxCharCode; i++) {\n    indexMap.push(-1);\n  }\n\n  for (let i = 0; i < alphabet.length; i++) {\n    indexMap[alphabet.charCodeAt(i)] = i;\n  }\n\n  return alphabetIndexMapCache[alphabet] = indexMap;\n}\n\nexport function _indexOfNumEnd(a: string, lengthA: number, numStartA: number)\n{\n  while (numStartA < lengthA && isNumberCode(a.charCodeAt(numStartA)))\n  {\n    ++numStartA;\n  }\n  return numStartA\n}\n\nexport function _alphabetCompare(charCodeA: number, charCodeB: number, alphabetIndexMap: IAlphabetIndexMap)\n{\n  if (charCodeA !== charCodeB) {\n    if (\n      charCodeA < alphabetIndexMap.length &&\n      charCodeB < alphabetIndexMap.length &&\n      alphabetIndexMap[charCodeA] !== -1 &&\n      alphabetIndexMap[charCodeB] !== -1\n    ) {\n      return alphabetIndexMap[charCodeA] - alphabetIndexMap[charCodeB];\n    }\n\n    return charCodeA - charCodeB;\n  }\n\n  return 0 as const\n}\n\nexport function _strLength(a: string, name: string)\n{\n  if (typeof a !== 'string')\n  {\n    throw new TypeError(`The ${name} argument must be a string. Received type '${typeof a}'`);\n  }\n\n  return a.length;\n}\n\nexport default naturalCompare;\n\n// @ts-ignore\nif (process.env.TSDX_FORMAT !== 'esm')\n{\n  Object.defineProperty(naturalCompare, \"__esModule\", { value: true });\n\n  Object.defineProperty(naturalCompare, 'naturalCompare', { value: naturalCompare });\n  Object.defineProperty(naturalCompare, 'default', { value: naturalCompare });\n\n  Object.defineProperty(naturalCompare, 'isNumberCode', { value: isNumberCode });\n  Object.defineProperty(naturalCompare, 'buildAlphabetIndexMap', { value: buildAlphabetIndexMap });\n\n  Object.defineProperty(naturalCompare, '_indexOfNumEnd', { value: _indexOfNumEnd });\n  Object.defineProperty(naturalCompare, '_alphabetCompare', { value: _alphabetCompare });\n  Object.defineProperty(naturalCompare, '_strLength', { value: _strLength });\n}\n"],"names":["alphabetIndexMapCache","defaultAlphabetIndexMap","isNumberCode","code","naturalCompare","a","b","opts","lengthA","_strLength","lengthB","indexA","indexB","alphabetIndexMap","firstDifferenceInLeadingZeros","caseInsensitive","toLowerCase","alphabet","buildAlphabetIndexMap","difference","charCodeA","charCodeAt","charCodeB","numStartA","numStartB","numEndA","_indexOfNumEnd","numEndB","_alphabetCompare","existingMap","undefined","indexMap","maxCharCode","split","reduce","maxCode","char","Math","max","i","push","length","name","TypeError"],"mappings":"AAeA,MAAMA,IAA2D,CAAA,GAC3DC,IAA6C;;AAE7C,SAAUC,aAAaC;EAC3B,OAAOA,KAAQ,MAAeA,KAAQ;AACxC;;SAEgBC,eAAeC,GAAWC,GAAWC;EACnD,MAAMC,IAAUC,WAAWJ,GAAG,MACxBK,IAAUD,WAAWH,GAAG;EAC9B,IAAIK,IAAS,GACTC,IAAS,GACTC,IAAmBZ,GACnBa,IAAgC;EAapC,KAXIP,MACEA,EAAKQ,oBACPV,IAAIA,EAAEW,eACNV,IAAIA,EAAEU,gBAGJT,EAAKU,aACPJ,IAAmBK,sBAAsBX,EAAKU,aAI3CN,IAASH,KAAWI,IAASF,KAAS;IAC3C,IAEIS,GAFAC,IAAYf,EAAEgB,WAAWV,IACzBW,IAAYhB,EAAEe,WAAWT;IAG7B,IAAIV,aAAakB,IAAjB;MACE,KAAKlB,aAAaoB,IAChB,OAAOF,IAAYE;MAGrB,IAAIC,IAAYZ,GACZa,IAAYZ;MAEhB,MAAqB,OAAdQ,OAA+BG,IAAYf,KAChDY,IAAYf,EAAEgB,WAAWE;MAE3B,MAAqB,OAAdD,OAA+BE,IAAYd,KAChDY,IAAYhB,EAAEe,WAAWG;MAGvBD,MAAcC,KAA+C,MAAlCV,MAC7BA,IAAgCS,IAAYC;MAG9C,IAAIC,IAAUC,eAAerB,GAAGG,GAASe,IACrCI,IAAUD,eAAepB,GAAGI,GAASc;MAGzC,IADAL,IAAaM,IAAUF,IAAYI,IAAUH,GAC1B,MAAfL,GACF,OAAOA;MAGT,MAAOI,IAAYE,KAEjB,IADAN,IAAad,EAAEgB,WAAWE,OAAejB,EAAEe,WAAWG,MACnC,MAAfL,GACF,OAAOA;MAIXR,IAASc,GACTb,IAASe;AAEV,WArCD;MAuCA,IAAI,OAAOR,IAAaS,iBAAiBR,GAAWE,GAAWT,KAE7D,OAAOM;QAGPR,KACAC;AARD;AASF;EAED,OAAID,IAASH,IACJ,IAGLI,IAASF,KACH,IAGHI;AACT;;AAEM,SAAUI,sBAAsBD;EACpC,MAAMY,IAAc7B,EAAsBiB;EAC1C,SAAoBa,MAAhBD,GACF,OAAOA;EAGT,MAAME,IAA8B,IAC9BC,IAAcf,EAASgB,MAAM,IAAIC,QAAO,CAACC,GAASC,MAC/CC,KAAKC,IAAIH,GAASC,EAAKf,WAAW,MACxC;EAEH,KAAK,IAAIkB,IAAI,GAAGA,KAAKP,GAAaO,KAChCR,EAASS,MAAM;EAGjB,KAAK,IAAID,IAAI,GAAGA,IAAItB,EAASwB,QAAQF,KACnCR,EAASd,EAASI,WAAWkB,MAAMA;EAGrC,OAAOvC,EAAsBiB,KAAYc;AAC3C;;SAEgBL,eAAerB,GAAWG,GAAiBe;EAEzD,MAAOA,IAAYf,KAAWN,aAAaG,EAAEgB,WAAWE,SAEpDA;EAEJ,OAAOA;AACT;;SAEgBK,iBAAiBR,GAAmBE,GAAmBT;EAErE,OAAIO,MAAcE,IAEdF,IAAYP,EAAiB4B,UAC7BnB,IAAYT,EAAiB4B,WACI,MAAjC5B,EAAiBO,OACgB,MAAjCP,EAAiBS,KAEVT,EAAiBO,KAAaP,EAAiBS,KAGjDF,IAAYE,IAGd;AACT;;AAEgB,SAAAb,WAAWJ,GAAWqC;EAEpC,IAAiB,mBAANrC,GAET,MAAM,IAAIsC,UAAiB,OAAAD,sDAAyDrC;EAGtF,OAAOA,EAAEoC;AACX;;"}