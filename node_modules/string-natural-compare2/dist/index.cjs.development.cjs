'use strict';

const alphabetIndexMapCache = {};
const defaultAlphabetIndexMap = [];
function isNumberCode(code) {
  return code >= 48 && code <= 57;
}
function naturalCompare(a, b, opts) {
  const lengthA = _strLength(a, 'a');
  const lengthB = _strLength(b, 'b');
  let indexA = 0;
  let indexB = 0;
  let alphabetIndexMap = defaultAlphabetIndexMap;
  let firstDifferenceInLeadingZeros = 0;
  if (opts) {
    if (opts.caseInsensitive) {
      a = a.toLowerCase();
      b = b.toLowerCase();
    }
    if (opts.alphabet) {
      alphabetIndexMap = buildAlphabetIndexMap(opts.alphabet);
    }
  }
  while (indexA < lengthA && indexB < lengthB) {
    let charCodeA = a.charCodeAt(indexA);
    let charCodeB = b.charCodeAt(indexB);
    let difference;
    if (isNumberCode(charCodeA)) {
      if (!isNumberCode(charCodeB)) {
        return charCodeA - charCodeB;
      }
      let numStartA = indexA;
      let numStartB = indexB;
      while (charCodeA === 48 && ++numStartA < lengthA) {
        charCodeA = a.charCodeAt(numStartA);
      }
      while (charCodeB === 48 && ++numStartB < lengthB) {
        charCodeB = b.charCodeAt(numStartB);
      }
      if (numStartA !== numStartB && firstDifferenceInLeadingZeros === 0) {
        firstDifferenceInLeadingZeros = numStartA - numStartB;
      }
      let numEndA = _indexOfNumEnd(a, lengthA, numStartA);
      let numEndB = _indexOfNumEnd(b, lengthB, numStartB);
      difference = numEndA - numStartA - numEndB + numStartB;
      if (difference !== 0) {
        return difference;
      }
      while (numStartA < numEndA) {
        difference = a.charCodeAt(numStartA++) - b.charCodeAt(numStartB++);
        if (difference !== 0) {
          return difference;
        }
      }
      indexA = numEndA;
      indexB = numEndB;
      continue;
    }
    if (0 !== (difference = _alphabetCompare(charCodeA, charCodeB, alphabetIndexMap))) {
      return difference;
    }
    ++indexA;
    ++indexB;
  }
  if (indexA < lengthA) {
    return 1;
  }
  if (indexB < lengthB) {
    return -1;
  }
  return firstDifferenceInLeadingZeros;
}
function buildAlphabetIndexMap(alphabet) {
  const existingMap = alphabetIndexMapCache[alphabet];
  if (existingMap !== undefined) {
    return existingMap;
  }
  const indexMap = [];
  const maxCharCode = alphabet.split('').reduce((maxCode, char) => {
    return Math.max(maxCode, char.charCodeAt(0));
  }, 0);
  for (let i = 0; i <= maxCharCode; i++) {
    indexMap.push(-1);
  }
  for (let i = 0; i < alphabet.length; i++) {
    indexMap[alphabet.charCodeAt(i)] = i;
  }
  return alphabetIndexMapCache[alphabet] = indexMap;
}
function _indexOfNumEnd(a, lengthA, numStartA) {
  while (numStartA < lengthA && isNumberCode(a.charCodeAt(numStartA))) {
    ++numStartA;
  }
  return numStartA;
}
function _alphabetCompare(charCodeA, charCodeB, alphabetIndexMap) {
  if (charCodeA !== charCodeB) {
    if (charCodeA < alphabetIndexMap.length && charCodeB < alphabetIndexMap.length && alphabetIndexMap[charCodeA] !== -1 && alphabetIndexMap[charCodeB] !== -1) {
      return alphabetIndexMap[charCodeA] - alphabetIndexMap[charCodeB];
    }
    return charCodeA - charCodeB;
  }
  return 0;
}
function _strLength(a, name) {
  if (typeof a !== 'string') {
    throw new TypeError(`The ${name} argument must be a string. Received type '${typeof a}'`);
  }
  return a.length;
}
{
  Object.defineProperty(naturalCompare, "__esModule", {
    value: true
  });
  Object.defineProperty(naturalCompare, 'naturalCompare', {
    value: naturalCompare
  });
  Object.defineProperty(naturalCompare, 'default', {
    value: naturalCompare
  });
  Object.defineProperty(naturalCompare, 'isNumberCode', {
    value: isNumberCode
  });
  Object.defineProperty(naturalCompare, 'buildAlphabetIndexMap', {
    value: buildAlphabetIndexMap
  });
  Object.defineProperty(naturalCompare, '_indexOfNumEnd', {
    value: _indexOfNumEnd
  });
  Object.defineProperty(naturalCompare, '_alphabetCompare', {
    value: _alphabetCompare
  });
  Object.defineProperty(naturalCompare, '_strLength', {
    value: _strLength
  });
}

// @ts-ignore
module.exports = naturalCompare;
//# sourceMappingURL=index.cjs.development.cjs.map
