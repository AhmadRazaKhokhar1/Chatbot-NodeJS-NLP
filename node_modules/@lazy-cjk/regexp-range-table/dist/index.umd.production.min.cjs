!function(e, r) {
  "object" == typeof exports && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define([ "exports" ], r) : r((e = "undefined" != typeof globalThis ? globalThis : e || self).LazyCjkRegexpRangeTable = {});
}(this, (function(e) {
  "use strict";
  const r = [ [ "〇", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十" ], [ "零", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十" ], [ "〇", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十" ], [ "〇", "壱", "弐", "参", "四", "五", "六", "七", "八", "九", "十" ], [ "零", "壱", "弐", "参", "肆", "伍", "陸", "柒", "捌", "玖", "拾" ], [ "零", "壹", "貳", "參", "肆", "伍", "陸", "柒", "捌", "玖", "拾" ], [ "零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖", "拾" ], [ "零", "壱", "弐", "参", "肆", "伍", "陸", "柒", "捌", "玖", "什" ], [ "零", "壹", "貳", "參", "肆", "伍", "陸", "柒", "捌", "玖", "什" ], [ "零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖", "什" ] ], n = [ [ "洞", "幺", "两", "三", "刀", "五", "六", "拐", "八", "勾" ] ], t = [ [ "⓪", "①", "②", "③", "④", "⑤", "⑥", "⑦", "⑧", "⑨", "⑩", "⑪", "⑫", "⑬", "⑭", "⑮", "⑯", "⑰", "⑱", "⑲", "⑳", "㉑", "㉒", "㉓", "㉔", "㉕", "㉖", "㉗", "㉘", "㉙", "㉚", "㉛", "㉜", "㉝", "㉞", "㉟", "㊱", "㊲", "㊳", "㊴", "㊵", "㊶", "㊷", "㊸", "㊹", "㊺", "㊻", "㊼", "㊽", "㊾", "㊿" ], [ "⓿", "❶", "❷", "❸", "❹", "❺", "❻", "❼", "❽", "❾", "❿", "⓫", "⓬", "⓭", "⓮", "⓯", "⓰", "⓱", "⓲", "⓳", "⓴" ], [ "❶", "❷", "❸", "❹", "❺", "❻", "❼", "❽", "❾", "❿", "⓫", "⓬", "⓭", "⓮", "⓯", "⓰", "⓱", "⓲", "⓳", "⓴" ], [ "➊", "➋", "➌", "➍", "➎", "➏", "➐", "➑", "➒", "➓", "⓫", "⓬", "⓭", "⓮", "⓯", "⓰", "⓱", "⓲", "⓳", "⓴" ], [ "⓵", "⓶", "⓷", "⓸", "⓹", "⓺", "⓻", "⓼", "⓽", "⓾" ], [ "➀", "➁", "➂", "➃", "➄", "➅", "➆", "➇", "➈", "➉" ] ], o = [ [ "Ⅰ", "Ⅱ", "Ⅲ", "Ⅳ", "Ⅴ", "Ⅵ", "Ⅶ", "Ⅷ", "Ⅸ", "Ⅹ", "Ⅺ", "Ⅻ" ], [ "ⅰ", "ⅱ", "ⅲ", "ⅳ", "ⅴ", "ⅵ", "ⅶ", "ⅷ", "ⅸ", "ⅹ", "ⅺ", "ⅻ" ] ], i = {
    chinese: r,
    chinese2: n,
    circle: t
  }, f = {
    chinese: r,
    chinese2: n,
    circle: t,
    roman: o
  };
  e.TABLE_RANGE = i, e.TABLE_RANGE_ALL = f, e.default = i, e.listRawToRange = function listRawToRange(e) {
    return e.reduce((function(e, r) {
      let n = r.reduce((function(e, r) {
        let n;
        if ("number" == typeof r) n = String.fromCharCode(r); else if ("string" == typeof r) n = r; else {
          if (!Array.isArray(r)) throw new TypeError;
          if (2 != r.length) throw new TypeError;
          n = new Array(r[1] - r[0]).fill(0).map((function(e, n) {
            return String.fromCharCode(r[0] + n);
          }));
        }
        return Array.isArray(n) ? e = e.concat(n) : e.push(n), e;
      }), []);
      return e.push(n), e;
    }), []);
  }, e.roman = o, Object.defineProperty(e, "__esModule", {
    value: !0
  });
}));
//# sourceMappingURL=index.umd.production.min.cjs.map
