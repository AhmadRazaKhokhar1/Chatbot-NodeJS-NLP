{"version":3,"file":"index.cjs.production.min.cjs","sources":["../src/index.ts"],"sourcesContent":["export const REGEXP_TO_STRING_TAG = Object.prototype.toString.call(/a/) as string;\n\nexport function toHex(n: number, toUpperCase?: boolean)\n{\n\tconst s = n.toString(16).padStart(4, '0');\n\treturn toUpperCase ? s.toUpperCase() : s;\n}\n\n/**\n * @code\n * console.log(core.toUnicode('𠮷')); // => \\u{20bb7}\n * console.log(core.toUnicode('𠮷'.codePointAt(0)));\n *\n * console.log(core.toUnicode('𠮷', true)); // => \\ud842\\udfb7\n * console.log(core.toUnicode('𠮷'.codePointAt(0), true));\n *\n * /[𠮷]/u.test('𠮷')\n * /[\\u{20bb7}]/u.test('𠮷')\n * /[\\ud842\\udfb7]/u.test('𠮷')\n */\nexport function toUnicode(charCode: number | string, noMerge?: boolean, wrap?: boolean)\n{\n\tlet s: string;\n\n\tif (typeof charCode === 'string')\n\t{\n\t\ts = charCode;\n\t\tcharCode = s.codePointAt(0);\n\t}\n\n\tif (charCode > 0xffff && noMerge)\n\t{\n\t\tlet p: number[];\n\n\t\tif (typeof s !== 'string')\n\t\t{\n\t\t\t//s = String.fromCodePoint(charCode);\n\t\t\tp = surrogatePair(charCode);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tp = [s.charCodeAt(0), s.charCodeAt(1)];\n\t\t}\n\n\t\treturn p.map(function (n)\n\t\t{\n\t\t\treturn _toUnicode(n, wrap);\n\t\t}).join('');\n\t}\n\n\treturn _toUnicode(charCode, wrap);\n}\n\nexport function toUnicode2(charCode: number | string, options: {\n\tnoMerge?: boolean,\n\twrap?: boolean\n} = {})\n{\n\treturn toUnicode(charCode, options.noMerge, options.wrap)\n}\n\nexport function _toUnicode(charCode: number, wrap?: boolean): `\\\\u${string}` | `\\\\u{${string}}`\n{\n\tconst hex = toHex(charCode);\n\treturn (wrap || hex.length > 4) ? `\\\\u{${hex}}` as const : `\\\\u${hex}` as const;\n}\n\nexport function isDoubleUnicode(str: string)\n{\n\treturn str.charCodeAt(0) === str.codePointAt(0);\n}\n\nexport function isRegExp<T extends RegExp>(r: T): T & RegExp\nexport function isRegExp(r: RegExp): r is RegExp\nexport function isRegExp(r: unknown): RegExp | null\nexport function isRegExp(r: unknown)\n{\n\tif ((r instanceof RegExp) || Object.prototype.toString.call(r) === REGEXP_TO_STRING_TAG)\n\t{\n\t\treturn r;\n\t}\n\n\treturn null;\n}\n\n/**\n * @link https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n * @link https://github.com/ikatyang/regexp-util/blob/7810ce61ff8becd728b745eb6d5c1ca76adfebe0/src/charset.ts#L289\n *\n * @code\n * surrogatePair('𠮷'.codePointAt(0)) // => { h: 55362, l: 57271 }\n * console.log('𠮷'.charCodeAt(0), '𠮷'.charCodeAt(1)) // => 55362 57271\n */\nexport function surrogatePair(codepoint: number)\n{\n\tconst h = Math.floor((codepoint - 0x10000) / 0x400) + 0xd800;\n\tconst l = (codepoint - 0x10000) % 0x400 + 0xdc00;\n\n\treturn Object.assign([h, l] as [number, number], {\n\t\th,\n\t\tl,\n\t});\n}\n\n/**\n * https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n *\n * @code\n * unicodeUnEscape('\\\\u{48}\\\\u{65}\\\\u{6c}\\\\u{6c}\\\\u{6f}\\\\u{20}\\\\u{77}\\\\u{6f}\\\\u{72}\\\\u{6c}\\\\u{64}') // => 'Hello world'\n * unicodeUnEscape('\\\\u{20bb7}') // => '𠮷'\n */\nexport function unicodeUnEscape(string: string, noLeadingSolidus?: boolean)\n{\n\t// note: this will match `u{123}` (no leading `\\`) as well\n\tconst r = noLeadingSolidus ? /u\\{([0-9a-fA-F]{1,8})\\}/g : /\\\\u\\{([0-9a-fA-F]{1,8})\\}/g;\n\n\treturn string.replace(r, ($0, $1) =>\n\t{\n\t\treturn String.fromCodePoint(parseInt($1, 16));\n\t});\n}\n\nexport function unicodeUnEscape2(string: string, options: {\n\tnoLeadingSolidus?: boolean,\n} = {})\n{\n\treturn unicodeUnEscape(string, options.noLeadingSolidus)\n}\n\n/**\n * @code\n * unicodeEscape('𠮷') // => '\\\\u{20bb7}'\n */\nexport function unicodeEscape(string: string,\n\tnoLeadingSolidus?: boolean,\n\tnoMerge?: boolean,\n\tnoWrap?: boolean,\n\tfilter = /./ug\n)\n{\n\treturn string.replace(filter, ($0) =>\n\t{\n\t\tconst s = toUnicode($0, noMerge, !noWrap);\n\n\t\treturn noLeadingSolidus ? s.replace(/\\\\/, '') : s;\n\t});\n}\n\nexport function unicodeEscape2(string: string, options: {\n\tnoLeadingSolidus?: boolean,\n\tnoMerge?: boolean,\n\tnoWrap?: boolean,\n\tfilter?: RegExp\n} = {})\n{\n\treturn unicodeEscape(string, options.noLeadingSolidus, options.noMerge, options.noWrap, options.filter)\n}\n\nexport function escapeRegExp(str: string)\n{\n\treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nexport default {\n\tREGEXP_TO_STRING_TAG,\n\t_toUnicode,\n\tescapeRegExp,\n\tisDoubleUnicode,\n\tisRegExp,\n\tsurrogatePair,\n\ttoHex,\n\ttoUnicode,\n\ttoUnicode2,\n\tunicodeEscape,\n\tunicodeEscape2,\n\tunicodeUnEscape,\n\tunicodeUnEscape2\n}\n"],"names":["toUpperCase","s","charCode","codePointAt","noMerge","p","charCodeAt","n","_toUnicode","wrap","join","toUnicode2","options","toUnicode","hex","toHex","isRegExp","r","RegExp","Object","prototype","toString","call","REGEXP_TO_STRING_TAG","h","Math","floor","codepoint","l","unicodeUnEscape","string","noLeadingSolidus","String","fromCodePoint","parseInt","unicodeEscape","noWrap","filter"],"mappings":";;;;;;;;;;EAAa,OAAAA,IAAAC,EAAAD,gBAA8BC;AAI1C;;;;EA4BC,6BARDA,IAAAC,OAEcD,EAAAE,YAAA,KAMbD,IAAI,UAAYE,GAEhB;IAGC,IAAAC;eACA,mBAAAJ,yBAUDA,EAAAK,WAAAL,IAAAA,EAEDK,WAAA;IAGDD,gBAA0BE;MAKzB,OAAAC,WAAAD,GAAAE;AAGD,QAAAC,KAAA;;;;;SASCC,WAAAT,GAAAU,IAAA;SAKKC,UAAAX,GAAAU,EAAAR,SAAAQ,EAAAH;;;SAKJD,WAAAN,GAAAO;EAED,MAAAK,IAAAC,MAAAb;yBAAAY,IAAAA,OAAAA,aAAAA;AAGD;;;;AAAA;;AAQgBE,SAAAA,SAAaC;sBAGRC,UAAUC,OAAAC,UAAAC,SAAAC,KAAAL,OAAAM,IAEvBN,IALR;AAQE;;;EASC,MAAAO,IAAAC,KAAAC,OAAAC,gCAmBHC,KAAAD,IAAA,WAAA,QAAA;;;;;;;SAgCCE,gBAAAC,GAAAC;mBAEcA,IAAA,6BAAA,yCAlBdC,OAAAC,cAAAC;;;;;;;SA+BgBC,cAAAL,GAAAC,GAAA3B,GAAAgC,GAAAC,IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}