!function(e, r) {
  "object" == typeof exports && "undefined" != typeof module ? r(exports, require("is-mergeable-object")) : "function" == typeof define && define.amd ? define([ "exports", "is-mergeable-object" ], r) : r((e = "undefined" != typeof globalThis ? globalThis : e || self).DeepmergePlus = {}, e.isMergeableObject);
}(this, (function(e, r) {
  "use strict";
  function cloneUnlessOtherwiseSpecified(e, r, t) {
    const l = (!r || !1 !== r.clone) && _isMergeableObject(e, r, t);
    let n = l ? deepmerge(function emptyTarget(e) {
      return Array.isArray(e) ? [] : {};
    }(e), e, r) : e;
    return null != r && r.keyValueOrMode && !l && t && "key" in t && (t.destination && (n = t.destination[t.key] || n), 
    t.target && (n = t.target[t.key] || n), t.source && (n = t.source[t.key] || n)), 
    n;
  }
  function _isMergeableObject(e, l, n) {
    var i;
    let a = null == l || null === (i = l.isMergeableObject) || void 0 === i ? void 0 : i.call(l, e, r, l, n);
    return null == a && (a = "boolean" == typeof (null == e ? void 0 : e[t]) ? e[t] : r(e)), 
    a;
  }
  function defaultArrayMerge(e, r, t) {
    return e.concat(r).map((function(e, r, l) {
      return cloneUnlessOtherwiseSpecified(e, t, {
        key: r
      });
    }));
  }
  function deepmerge(e, r, t) {
    const l = Array.isArray(r);
    return l === Array.isArray(e) ? l ? ((t || {
      arrayMerge: defaultArrayMerge
    }).arrayMerge || defaultArrayMerge)(e, r, t) : function mergeObject(e, r, t) {
      let l = {};
      return _isMergeableObject(e, t) && Object.keys(e).forEach((function(n) {
        l[n] = cloneUnlessOtherwiseSpecified(e[n], t, {
          key: n,
          source: r,
          target: e,
          destination: l
        });
      })), Object.keys(r).forEach((function(n) {
        l[n] = _isMergeableObject(r[n], t, {
          key: n,
          source: r,
          target: e
        }) && e[n] ? deepmerge(e[n], r[n], t) : cloneUnlessOtherwiseSpecified(r[n], t, {
          key: n,
          source: r,
          target: e
        });
      })), l;
    }(e, r, t) : cloneUnlessOtherwiseSpecified(r, t, {
      target: e,
      source: r
    });
  }
  function isMergeable(e) {
    return r(e);
  }
  const t = Symbol.for("SYMBOL_IS_MERGEABLE");
  function deepmergeAll(e, r) {
    if (!Array.isArray(e)) throw new Error("first argument should be an array");
    return e.reduce((function(e, t) {
      return deepmerge(e, t, r);
    }), {});
  }
  Object.defineProperty(deepmerge, "__esModule", {
    value: !0
  }), Object.defineProperty(deepmerge, "deepmerge", {
    value: deepmerge
  }), Object.defineProperty(deepmerge, "default", {
    value: deepmerge
  }), Object.defineProperty(deepmerge, "isMergeable", {
    value: isMergeable
  }), Object.defineProperty(deepmerge, "SYMBOL_IS_MERGEABLE", {
    value: t
  }), Object.defineProperty(deepmerge, "deepmergeAll", {
    value: deepmergeAll
  }), Object.defineProperty(deepmerge, "all", {
    value: deepmergeAll
  }), Object.defineProperty(deepmerge, "_isMergeableObject", {
    value: _isMergeableObject
  }), e.SYMBOL_IS_MERGEABLE = t, e._isMergeableObject = _isMergeableObject, e.all = deepmergeAll, 
  e.deepmerge = deepmerge, e.deepmergeAll = deepmergeAll, e.default = deepmerge, e.isMergeable = isMergeable, 
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
}));
//# sourceMappingURL=index.umd.production.min.cjs.map
