{"version":3,"file":"index.umd.production.min.cjs","sources":["../src/index.ts"],"sourcesContent":["import isMergeableObject from 'is-mergeable-object';\n\nfunction emptyTarget(val)\n{\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, optionsArgument: IOptions, tmp?: ICache)\n{\n\tconst clone = !optionsArgument || optionsArgument.clone !== false;\n\n\tconst bool = clone && _isMergeableObject(value, optionsArgument, tmp);\n\n\tlet ret = (bool)\n\t\t? deepmerge(emptyTarget(value), value, optionsArgument)\n\t\t: value;\n\n\tif (optionsArgument?.keyValueOrMode && !bool && tmp && ('key' in tmp))\n\t{\n\t\tif (tmp.destination)\n\t\t{\n\t\t\t//console.log('destination', tmp.destination[tmp.key], ret, tmp.key);\n\t\t\tret = tmp.destination[tmp.key] || ret;\n\t\t}\n\n\t\tif (tmp.target)\n\t\t{\n\t\t\t//console.log('target', tmp.target[tmp.key], ret, tmp.key);\n\t\t\tret = tmp.target[tmp.key] || ret;\n\t\t}\n\n\t\tif (tmp.source)\n\t\t{\n\t\t\t//console.log('source', tmp.source[tmp.key], ret, tmp.key);\n\t\t\tret = tmp.source[tmp.key] || ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nexport function _isMergeableObject(value, optionsArgument: IOptions, tmp?: ICache): boolean\n{\n\tlet ret = optionsArgument?.isMergeableObject?.(value, isMergeableObject, optionsArgument, tmp) as any;\n\n\tif (ret === null || typeof ret === 'undefined')\n\t{\n\t\tif ((typeof value?.[SYMBOL_IS_MERGEABLE] == 'boolean'))\n\t\t{\n\t\t\tret = value[SYMBOL_IS_MERGEABLE];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = isMergeableObject(value);\n\t\t}\n\t}\n\treturn ret\n}\n\nfunction defaultArrayMerge(target, source, optionsArgument: IOptions)\n{\n\treturn target.concat(source).map(function (element, index, array)\n\t{\n\t\treturn cloneUnlessOtherwiseSpecified(element, optionsArgument, {\n\t\t\tkey: index,\n\t\t})\n\t})\n}\n\nfunction mergeObject(target, source, optionsArgument: IOptions)\n{\n\tlet destination = {};\n\tif (_isMergeableObject(target, optionsArgument))\n\t{\n\t\tObject.keys(target).forEach(function (key)\n\t\t{\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument, {\n\t\t\t\tkey,\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t\tdestination,\n\t\t\t})\n\t\t})\n\t}\n\tObject.keys(source).forEach(function (key)\n\t{\n\t\tif (!_isMergeableObject(source[key], optionsArgument, {\n\t\t\t\tkey,\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t}) || !target[key])\n\t\t{\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument, {\n\t\t\t\tkey,\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t})\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdestination[key] = deepmerge(target[key], source[key], optionsArgument)\n\t\t}\n\t});\n\treturn destination\n}\n\nexport function deepmerge<T1, T2>(x: T1, y: T2, options?: IOptions): Partial<T1 & T2>\nexport function deepmerge<T>(x: Partial<T>, y: Partial<T>, options?: IOptions): Partial<T>\nexport function deepmerge(target, source, optionsArgument)\n{\n\tconst sourceIsArray = Array.isArray(source);\n\tconst targetIsArray = Array.isArray(target);\n\tconst options = optionsArgument || { arrayMerge: defaultArrayMerge };\n\tconst sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch)\n\t{\n\t\treturn cloneUnlessOtherwiseSpecified(source, optionsArgument, {\n\t\t\ttarget,\n\t\t\tsource,\n\t\t});\n\t}\n\telse if (sourceIsArray)\n\t{\n\t\tlet arrayMerge = options.arrayMerge || defaultArrayMerge;\n\t\treturn arrayMerge(target, source, optionsArgument);\n\t}\n\telse\n\t{\n\t\treturn mergeObject(target, source, optionsArgument);\n\t}\n}\n\nexport interface ICache\n{\n\tkey?\n\tsource?\n\ttarget?\n\tdestination?\n}\n\nexport interface IOptions\n{\n\tclone?: boolean;\n\n\tarrayMerge?(destination: any[], source: any[], options?: IOptions): any[];\n\n\tisMergeableObject?(value, isMergeableObject: typeof isMergeable, optionsArgument?: IOptions, key?): void;\n\tisMergeableObject?(value, isMergeableObject: typeof isMergeable, optionsArgument?: IOptions, key?): boolean;\n\n\t/**\n\t * (val = old || new) mode\n\t */\n\tkeyValueOrMode?: boolean,\n}\n\nexport function isMergeable(value: any): boolean\n{\n\treturn isMergeableObject(value)\n}\n\nconst SYMBOL_IS_MERGEABLE = Symbol.for('SYMBOL_IS_MERGEABLE');\n\nexport { SYMBOL_IS_MERGEABLE }\n\nexport function deepmergeAll<T, T2 = any>(array: Array<Partial<T2 & T>>, optionsArgument?: IOptions): T2 & T\n{\n\tif (!Array.isArray(array))\n\t{\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\t// @ts-ignore\n\treturn array.reduce(function (prev, next)\n\t{\n\t\treturn deepmerge(prev, next, optionsArgument)\n\t}, {})\n}\n\nexport { deepmergeAll as all }\n\nexport default deepmerge\n\n// @ts-ignore\nif (process.env.TSDX_FORMAT !== 'esm')\n{\n\tObject.defineProperty(deepmerge, \"__esModule\", { value: true });\n\n\tObject.defineProperty(deepmerge, 'deepmerge', { value: deepmerge });\n\tObject.defineProperty(deepmerge, 'default', { value: deepmerge });\n\n\tObject.defineProperty(deepmerge, 'isMergeable', { value: isMergeable });\n\tObject.defineProperty(deepmerge, 'SYMBOL_IS_MERGEABLE', { value: SYMBOL_IS_MERGEABLE });\n\tObject.defineProperty(deepmerge, 'deepmergeAll', { value: deepmergeAll });\n\tObject.defineProperty(deepmerge, 'all', { value: deepmergeAll });\n\n\tObject.defineProperty(deepmerge, '_isMergeableObject', { value: _isMergeableObject });\n}\n"],"names":["cloneUnlessOtherwiseSpecified","value","optionsArgument","tmp","bool","clone","_isMergeableObject","ret","deepmerge","emptyTarget","val","Array","isArray","keyValueOrMode","destination","key","target","source","_optionsArgument$isMe","isMergeableObject","call","SYMBOL_IS_MERGEABLE","defaultArrayMerge","concat","map","element","index","array","sourceIsArray","arrayMerge","mergeObject","Object","keys","forEach","isMergeable","Symbol","for","deepmergeAll","Error","reduce","prev","next","defineProperty"],"mappings":"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"}