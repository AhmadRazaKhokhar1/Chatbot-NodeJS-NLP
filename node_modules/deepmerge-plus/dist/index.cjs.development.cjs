'use strict';

var isMergeableObject = require('is-mergeable-object');

function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, optionsArgument, tmp) {
  const clone = !optionsArgument || optionsArgument.clone !== false;
  const bool = clone && _isMergeableObject(value, optionsArgument, tmp);
  let ret = bool ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
  if (optionsArgument !== null && optionsArgument !== void 0 && optionsArgument.keyValueOrMode && !bool && tmp && 'key' in tmp) {
    if (tmp.destination) {
      //console.log('destination', tmp.destination[tmp.key], ret, tmp.key);
      ret = tmp.destination[tmp.key] || ret;
    }
    if (tmp.target) {
      //console.log('target', tmp.target[tmp.key], ret, tmp.key);
      ret = tmp.target[tmp.key] || ret;
    }
    if (tmp.source) {
      //console.log('source', tmp.source[tmp.key], ret, tmp.key);
      ret = tmp.source[tmp.key] || ret;
    }
  }
  return ret;
}
function _isMergeableObject(value, optionsArgument, tmp) {
  var _optionsArgument$isMe;
  let ret = optionsArgument === null || optionsArgument === void 0 || (_optionsArgument$isMe = optionsArgument.isMergeableObject) === null || _optionsArgument$isMe === void 0 ? void 0 : _optionsArgument$isMe.call(optionsArgument, value, isMergeableObject, optionsArgument, tmp);
  if (ret === null || typeof ret === 'undefined') {
    if (typeof (value === null || value === void 0 ? void 0 : value[SYMBOL_IS_MERGEABLE]) == 'boolean') {
      ret = value[SYMBOL_IS_MERGEABLE];
    } else {
      ret = isMergeableObject(value);
    }
  }
  return ret;
}
function defaultArrayMerge(target, source, optionsArgument) {
  return target.concat(source).map(function (element, index, array) {
    return cloneUnlessOtherwiseSpecified(element, optionsArgument, {
      key: index
    });
  });
}
function mergeObject(target, source, optionsArgument) {
  let destination = {};
  if (_isMergeableObject(target, optionsArgument)) {
    Object.keys(target).forEach(function (key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument, {
        key,
        source,
        target,
        destination
      });
    });
  }
  Object.keys(source).forEach(function (key) {
    if (!_isMergeableObject(source[key], optionsArgument, {
      key,
      source,
      target
    }) || !target[key]) {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument, {
        key,
        source,
        target
      });
    } else {
      destination[key] = deepmerge(target[key], source[key], optionsArgument);
    }
  });
  return destination;
}
function deepmerge(target, source, optionsArgument) {
  const sourceIsArray = Array.isArray(source);
  const targetIsArray = Array.isArray(target);
  const options = optionsArgument || {
    arrayMerge: defaultArrayMerge
  };
  const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, optionsArgument, {
      target,
      source
    });
  } else if (sourceIsArray) {
    let arrayMerge = options.arrayMerge || defaultArrayMerge;
    return arrayMerge(target, source, optionsArgument);
  } else {
    return mergeObject(target, source, optionsArgument);
  }
}
function isMergeable(value) {
  return isMergeableObject(value);
}
const SYMBOL_IS_MERGEABLE = /*#__PURE__*/Symbol.for('SYMBOL_IS_MERGEABLE');
function deepmergeAll(array, optionsArgument) {
  if (!Array.isArray(array)) {
    throw new Error('first argument should be an array');
  }
  // @ts-ignore
  return array.reduce(function (prev, next) {
    return deepmerge(prev, next, optionsArgument);
  }, {});
}
// @ts-ignore
{
  Object.defineProperty(deepmerge, "__esModule", {
    value: true
  });
  Object.defineProperty(deepmerge, 'deepmerge', {
    value: deepmerge
  });
  Object.defineProperty(deepmerge, 'default', {
    value: deepmerge
  });
  Object.defineProperty(deepmerge, 'isMergeable', {
    value: isMergeable
  });
  Object.defineProperty(deepmerge, 'SYMBOL_IS_MERGEABLE', {
    value: SYMBOL_IS_MERGEABLE
  });
  Object.defineProperty(deepmerge, 'deepmergeAll', {
    value: deepmergeAll
  });
  Object.defineProperty(deepmerge, 'all', {
    value: deepmergeAll
  });
  Object.defineProperty(deepmerge, '_isMergeableObject', {
    value: _isMergeableObject
  });
}

// @ts-ignore
module.exports = deepmerge;
//# sourceMappingURL=index.cjs.development.cjs.map
