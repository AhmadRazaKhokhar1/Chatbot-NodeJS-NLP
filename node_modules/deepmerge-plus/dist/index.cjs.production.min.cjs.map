{"version":3,"file":"index.cjs.production.min.cjs","sources":["../src/index.ts","../src/index.cts"],"sourcesContent":["import isMergeableObject from 'is-mergeable-object';\n\nfunction emptyTarget(val)\n{\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, optionsArgument: IOptions, tmp?: ICache)\n{\n\tconst clone = !optionsArgument || optionsArgument.clone !== false;\n\n\tconst bool = clone && _isMergeableObject(value, optionsArgument, tmp);\n\n\tlet ret = (bool)\n\t\t? deepmerge(emptyTarget(value), value, optionsArgument)\n\t\t: value;\n\n\tif (optionsArgument?.keyValueOrMode && !bool && tmp && ('key' in tmp))\n\t{\n\t\tif (tmp.destination)\n\t\t{\n\t\t\t//console.log('destination', tmp.destination[tmp.key], ret, tmp.key);\n\t\t\tret = tmp.destination[tmp.key] || ret;\n\t\t}\n\n\t\tif (tmp.target)\n\t\t{\n\t\t\t//console.log('target', tmp.target[tmp.key], ret, tmp.key);\n\t\t\tret = tmp.target[tmp.key] || ret;\n\t\t}\n\n\t\tif (tmp.source)\n\t\t{\n\t\t\t//console.log('source', tmp.source[tmp.key], ret, tmp.key);\n\t\t\tret = tmp.source[tmp.key] || ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nexport function _isMergeableObject(value, optionsArgument: IOptions, tmp?: ICache): boolean\n{\n\tlet ret = optionsArgument?.isMergeableObject?.(value, isMergeableObject, optionsArgument, tmp) as any;\n\n\tif (ret === null || typeof ret === 'undefined')\n\t{\n\t\tif ((typeof value?.[SYMBOL_IS_MERGEABLE] == 'boolean'))\n\t\t{\n\t\t\tret = value[SYMBOL_IS_MERGEABLE];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = isMergeableObject(value);\n\t\t}\n\t}\n\treturn ret\n}\n\nfunction defaultArrayMerge(target, source, optionsArgument: IOptions)\n{\n\treturn target.concat(source).map(function (element, index, array)\n\t{\n\t\treturn cloneUnlessOtherwiseSpecified(element, optionsArgument, {\n\t\t\tkey: index,\n\t\t})\n\t})\n}\n\nfunction mergeObject(target, source, optionsArgument: IOptions)\n{\n\tlet destination = {};\n\tif (_isMergeableObject(target, optionsArgument))\n\t{\n\t\tObject.keys(target).forEach(function (key)\n\t\t{\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument, {\n\t\t\t\tkey,\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t\tdestination,\n\t\t\t})\n\t\t})\n\t}\n\tObject.keys(source).forEach(function (key)\n\t{\n\t\tif (!_isMergeableObject(source[key], optionsArgument, {\n\t\t\t\tkey,\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t}) || !target[key])\n\t\t{\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument, {\n\t\t\t\tkey,\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t})\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdestination[key] = deepmerge(target[key], source[key], optionsArgument)\n\t\t}\n\t});\n\treturn destination\n}\n\nexport function deepmerge<T1, T2>(x: T1, y: T2, options?: IOptions): Partial<T1 & T2>\nexport function deepmerge<T>(x: Partial<T>, y: Partial<T>, options?: IOptions): Partial<T>\nexport function deepmerge(target, source, optionsArgument)\n{\n\tconst sourceIsArray = Array.isArray(source);\n\tconst targetIsArray = Array.isArray(target);\n\tconst options = optionsArgument || { arrayMerge: defaultArrayMerge };\n\tconst sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch)\n\t{\n\t\treturn cloneUnlessOtherwiseSpecified(source, optionsArgument, {\n\t\t\ttarget,\n\t\t\tsource,\n\t\t});\n\t}\n\telse if (sourceIsArray)\n\t{\n\t\tlet arrayMerge = options.arrayMerge || defaultArrayMerge;\n\t\treturn arrayMerge(target, source, optionsArgument);\n\t}\n\telse\n\t{\n\t\treturn mergeObject(target, source, optionsArgument);\n\t}\n}\n\nexport interface ICache\n{\n\tkey?\n\tsource?\n\ttarget?\n\tdestination?\n}\n\nexport interface IOptions\n{\n\tclone?: boolean;\n\n\tarrayMerge?(destination: any[], source: any[], options?: IOptions): any[];\n\n\tisMergeableObject?(value, isMergeableObject: typeof isMergeable, optionsArgument?: IOptions, key?): void;\n\tisMergeableObject?(value, isMergeableObject: typeof isMergeable, optionsArgument?: IOptions, key?): boolean;\n\n\t/**\n\t * (val = old || new) mode\n\t */\n\tkeyValueOrMode?: boolean,\n}\n\nexport function isMergeable(value: any): boolean\n{\n\treturn isMergeableObject(value)\n}\n\nconst SYMBOL_IS_MERGEABLE = Symbol.for('SYMBOL_IS_MERGEABLE');\n\nexport { SYMBOL_IS_MERGEABLE }\n\nexport function deepmergeAll<T, T2 = any>(array: Array<Partial<T2 & T>>, optionsArgument?: IOptions): T2 & T\n{\n\tif (!Array.isArray(array))\n\t{\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\t// @ts-ignore\n\treturn array.reduce(function (prev, next)\n\t{\n\t\treturn deepmerge(prev, next, optionsArgument)\n\t}, {})\n}\n\nexport { deepmergeAll as all }\n\nexport default deepmerge\n\n// @ts-ignore\nif (process.env.TSDX_FORMAT !== 'esm')\n{\n\tObject.defineProperty(deepmerge, \"__esModule\", { value: true });\n\n\tObject.defineProperty(deepmerge, 'deepmerge', { value: deepmerge });\n\tObject.defineProperty(deepmerge, 'default', { value: deepmerge });\n\n\tObject.defineProperty(deepmerge, 'isMergeable', { value: isMergeable });\n\tObject.defineProperty(deepmerge, 'SYMBOL_IS_MERGEABLE', { value: SYMBOL_IS_MERGEABLE });\n\tObject.defineProperty(deepmerge, 'deepmergeAll', { value: deepmergeAll });\n\tObject.defineProperty(deepmerge, 'all', { value: deepmergeAll });\n\n\tObject.defineProperty(deepmerge, '_isMergeableObject', { value: _isMergeableObject });\n}\n","import _ from './index';\n\n// @ts-ignore\nexport = _\n"],"names":["cloneUnlessOtherwiseSpecified","value","optionsArgument","tmp","bool","clone","_isMergeableObject","ret","deepmerge","emptyTarget","val","Array","isArray","keyValueOrMode","destination","key","target","source","_optionsArgument$isMe","isMergeableObject","call","SYMBOL_IS_MERGEABLE","defaultArrayMerge","concat","map","element","index","array","sourceIsArray","arrayMerge","mergeObject","Object","keys","forEach","Symbol","for","deepmergeAll","Error","reduce","prev","next","defineProperty","isMergeable","module","exports","_"],"mappings":"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"}