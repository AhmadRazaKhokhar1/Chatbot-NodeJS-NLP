{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";AAAA;;GAEG;;;;AAGH,6DAK6B;AAgBK,mGAlBjC,wCAAkB,OAkBiC;AAA3C,wGAjBR,6CAAuB,OAiBQ;AAfhC,qCASoB;AAEpB,qDAAoF;AACpF,+CAA+D;AAiJtD,6GAjJA,wCAA4B,OAiJA;AAhJrC,oDAA0B;AAQ1B;;GAEG;AACU,QAAA,cAAc,GAAa,EAAE,CAAC;AAE3C,MAAa,QAAS,SAAQ,MAAM;IAmDnC;;;OAGG;IACH,MAAM,CAAC,GAAG,CAAC,cAA6B;QAEvC,cAAc,GAAG,IAAA,4BAAa,EAAC,EAAE,EAAE,IAAI,CAAC,kBAAW,CAAC,EAAE,cAAc,CAAC,CAAC;QAEtE,MAAM,WAAW,GAAG,IAAI,KAAK,CAAC,QAAQ,EAAE;YACvC,aAAa;YACb,SAAS,CAAC,MAAuB,EAAE,QAAiB,EAAE,SAAe;gBAEpE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,gCAAiB,EAAC,GAAG,QAAmC,CAAC,CAAC;gBAE9F,OAAO,GAAG,IAAA,2BAAY,EAAC,EAAE,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;gBAEpD,OAAO,IAAI,QAAQ,CAAC,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,CAAC;YACnD,CAAC;YAED,aAAa;YACb,GAAG,CAAC,MAAsB,EAAE,GAAuC;gBAElE,IAAI,GAAG,KAAK,kBAAW,EACvB,CAAC;oBACA,OAAO,cAAc,CAAA;gBACtB,CAAC;gBAED,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;YACpB,CAAC;SAED,CAAC,CAAC;QAEH,OAAO,WAAW,CAAA;IACnB,CAAC;IAMD,YAAY,GAAG,EAAE,GAAG,IAAI;QAEvB,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,IAAA,kBAAW,EAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;QAElD,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IACtB,CAAC;IAID,MAAM,CAAC,MAAM,CAAe,GAAG,EAAE,KAAK,GAAG,IAAI,EAAE,IAAK,EAAE,GAAG,IAAI;QAE5D,OAAO,IAAI,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC;IAC5C,CAAC;IAED,SAAS;QAER,OAAO,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;IACpC,CAAC;IAED;;OAEG;IACH,yBAAyB;QAExB,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAC;QACvB,yCAAyC;IAC1C,CAAC;IAED,MAAM,CAAC,4BAA4B,CAAC,GAAW;QAE9C,OAAO,IAAA,wCAA4B,EAAC,GAAG,CAAC,CAAC;IAC1C,CAAC;IAED,MAAM,KAAK,OAAO;QAEjB,OAAO,OAAO,CAAC,gBAAgB,CAAC,CAAC,OAAO,CAAA;IACzC,CAAC;CACD;AA/HD,4BA+HC;AAEY,QAAA,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAA2B,CAAC;AAU/E,kBAAe,QAAQ,CAAC","sourcesContent":["/**\n * Created by user on 2018/1/31/031.\n */\n\nimport { IAstToStringOptions } from 'regexp-parser-literal';\nimport {\n\tINodeInput,\n\tIParserEventEmitterListener,\n\tParserEventEmitter,\n\tParserEventEmitterEvent,\n} from 'regexp-parser-event';\nimport {\n\tcoreHandler,\n\tICoreHandlerReturn,\n\tIOptions,\n\tIOptionsCore,\n\tIOptionsInput,\n\tIOptionsOn,\n\tIOptionsRuntime, IRegExpUserInput,\n\tSymDefaults,\n} from './lib/core';\nimport { IOptions as IOptionsZhTable } from '@lazy-cjk/zh-table-list';\nimport { mergeOptions, getSettingOptions, mergeOptions2 } from './lib/mergeOptions';\nimport { parseRegularExpressionString } from './lib/getSource';\nexport * from './version';\n\nexport { ParserEventEmitterEvent, ParserEventEmitter, INodeInput, IParserEventEmitterListener, IAstToStringOptions }\n\nexport { IOptions, IOptionsRuntime, IOptionsInput, ICoreHandlerReturn, IOptionsOn, IOptionsCore }\n\nexport { IOptionsZhTable }\n\n/**\n * @deprecated\n */\nexport const defaultOptions: IOptions = {};\n\nexport class zhRegExp extends RegExp\n{\n\tpublic override source: string;\n\tpublic override flags: string;\n\n\tpublic override dotAll: boolean;\n\n\tpublic override ignoreCase: boolean;\n\tpublic override global: boolean;\n\tpublic override multiline: boolean;\n\tpublic override sticky: boolean;\n\tpublic override unicode: boolean;\n\n\tpublic override lastIndex: number;\n\n\t/**\n\t * The non-standard leftContext property is a static and read-only property of regular expressions that contains the substring preceding the most recent match. RegExp.$` is an alias for this property.\n\t *\n\t * @alias $`\n\t */\n\tpublic static override readonly leftContext: string;\n\t/**\n\t * The non-standard rightContext property is a static and read-only property of regular expressions that contains the substring following the most recent match. RegExp.$' is an alias for this property.\n\t *\n\t * @alias $'\n\t */\n\tpublic static override readonly rightContext: string;\n\t/**\n\t * The non-standard lastParen property is a static and read-only property of regular expressions that contains the last parenthesized substring match, if any. RegExp.$+ is an alias for this property.\n\t *\n\t * @alias $+\n\t */\n\tpublic static override readonly lastParen: string;\n\t/**\n\t * The non-standard lastMatch property is a static and read-only property of regular expressions that contains the last matched characters. RegExp.$& is an alias for this property.\n\t *\n\t * @alias $&\n\t */\n\tpublic static override readonly lastMatch: string;\n\t/**\n\t * The non-standard input property is a static property of regular expressions that contains the string against which a regular expression is matched. RegExp.$_ is an alias for this property.\n\t *\n\t * @alias $_\n\t */\n\tpublic static override readonly input: string;\n\n\t/**\n\t * default value only exists and work when use `zhRegExp.use(defaultOptions)`\n\t */\n\tpublic static readonly [SymDefaults]: IOptionsInput;\n\n\t/**\n\t * create a new zhRegExp class with default value\n\t * @example `zhRegExp.use(defaultOptions)`\n\t */\n\tstatic use(defaultOptions: IOptionsInput): typeof zhRegExp\n\t{\n\t\tdefaultOptions = mergeOptions2({}, this[SymDefaults], defaultOptions);\n\n\t\tconst zhRegExpNew = new Proxy(zhRegExp, {\n\t\t\t// @ts-ignore\n\t\t\tconstruct(target: typeof zhRegExp, argArray: unknown, newTarget?: any)\n\t\t\t{\n\t\t\t\tlet { str, flags, options, argv } = getSettingOptions(...argArray as [IRegExpUserInput, any]);\n\n\t\t\t\toptions = mergeOptions({}, defaultOptions, options);\n\n\t\t\t\treturn new zhRegExp(str, flags, options, ...argv);\n\t\t\t},\n\n\t\t\t// @ts-ignore\n\t\t\tget(target: keyof zhRegExp, key: keyof zhRegExp |typeof SymDefaults)\n\t\t\t{\n\t\t\t\tif (key === SymDefaults)\n\t\t\t\t{\n\t\t\t\t\treturn defaultOptions\n\t\t\t\t}\n\n\t\t\t\treturn target[key];\n\t\t\t},\n\n\t\t});\n\n\t\treturn zhRegExpNew\n\t}\n\n\tconstructor(str: IRegExpUserInput, options?: IOptionsInput, ...argv)\n\tconstructor(str: IRegExpUserInput, flags?: string, options?: IOptionsInput, ...argv)\n\tconstructor(str: IRegExpUserInput, flags: string, skip: string, ...argv)\n\tconstructor(str: IRegExpUserInput, flags: string, options?: IOptionsInput | string, ...argv)\n\tconstructor(str, ...argv)\n\t{\n\t\tlet { source, flags } = coreHandler(str, ...argv);\n\n\t\tsuper(source, flags);\n\t}\n\n\tstatic create<T = zhRegExp>(str: IRegExpUserInput, flags?: string, options?: IOptionsInput | string): T\n\tstatic create<T = zhRegExp>(str: IRegExpUserInput, options?: IOptionsInput): T\n\tstatic create<T = zhRegExp>(str, flags = null, skip?, ...argv)\n\t{\n\t\treturn new this(str, flags, skip, ...argv);\n\t}\n\n\tgetStatic<T = typeof zhRegExp>(): T\n\t{\n\t\treturn Object.getPrototypeOf(this);\n\t}\n\n\t/**\n\t * @todo\n\t */\n\ttoRegularExpressionString()\n\t{\n\t\treturn this.toString();\n\t\t//return `/${this.source}/${this.flags}`;\n\t}\n\n\tstatic parseRegularExpressionString(str: string)\n\t{\n\t\treturn parseRegularExpressionString(str);\n\t}\n\n\tstatic get version(): string\n\t{\n\t\treturn require('./package.json').version\n\t}\n}\n\nexport const create = zhRegExp.create.bind(zhRegExp) as typeof zhRegExp.create;\n\nexport { parseRegularExpressionString }\n\nexport interface IApi<T = zhRegExp>\n{\n\t(str: string | RegExp, flags?: string, options?: IOptions | string): T,\n\t(str: string | RegExp, options?: IOptions): T,\n}\n\nexport default zhRegExp;\n"]}