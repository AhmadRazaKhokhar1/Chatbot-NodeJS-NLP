!function(e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t(exports, require("@lazy-array/util-unique")) : "function" == typeof define && define.amd ? define([ "exports", "@lazy-array/util-unique" ], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).SortObjectKeys = {}, e.utilUnique);
}(this, (function(e, t) {
  "use strict";
  function sortObjectKeys(e, r) {
    let s = {};
    "function" == typeof r ? s.sort = r : Array.isArray(r) ? s.keys = r : s = Object.assign(s, r);
    let {keys: o = [], useSource: n} = s;
    if (Array.isArray(o) && (o = o.slice()), s.onlyKeys) {
      if (n = !1, "number" != typeof o.length || 0 === o.length) throw new ReferenceError("options.key is empty or not exists.");
    } else o = o.concat(Object.keys(e).sort(s.sort));
    o = t.array_unique_indexOf(o), s.desc && (o = o.reverse());
    let y = o.reduce((function(t, r) {
      return (s.allowNotExists || r in e) && (t[r] = e[r]), t;
    }), {});
    return n ? (Object.keys(y).forEach((function(t) {
      delete e[t], e[t] = y[t];
    })), e) : y;
  }
  Object.defineProperty(sortObjectKeys, "sortObjectKeys", {
    value: sortObjectKeys
  }), Object.defineProperty(sortObjectKeys, "sortObject", {
    value: sortObjectKeys
  }), Object.defineProperty(sortObjectKeys, "default", {
    value: sortObjectKeys
  }), Object.defineProperty(sortObjectKeys, "__esModule", {
    value: !0
  }), e.default = sortObjectKeys, e.sortObject = sortObjectKeys, e.sortObjectKeys = sortObjectKeys, 
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
}));
//# sourceMappingURL=index.umd.production.min.cjs.map
