{"version":3,"file":"parser.js","sourceRoot":"","sources":["parser.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    AlternativeElement,\n    AnyCharacterSet,\n    Assertion,\n    Backreference,\n    CapturingGroup,\n    Character,\n    CharacterClass,\n    CharacterClassRange,\n    Disjunction,\n    Element,\n    EscapeCharacterSet,\n    Flags,\n    Group,\n    LookaroundAssertion,\n    Pattern,\n    QuantifiableElement,\n    Quantifier,\n    RegExpLiteral,\n    UnicodePropertyCharacterSet,\n} from \"./ast\"\nimport { assert, last } from \"./util\"\nimport { RegExpValidator } from \"./validator\"\nimport {\n    EnumEcmaVersion,\n    EnumError,\n    EnumKindAssertion,\n    EnumKindCharacterSet,\n    EnumKindEdgeAssertion,\n    EnumKindEscapeCharacterSet,\n    EnumKindLookAssertion,\n    EnumTypeNode,\n} from './const';\n\nexport type AppendableNode =\n    | Pattern\n    | Disjunction\n    | Group\n    | CapturingGroup\n    | CharacterClass\n    | LookaroundAssertion\n\nconst DummyPattern = {} as Pattern\nconst DummyFlags = {} as Flags\nconst DummyCapturingGroup = {} as CapturingGroup\n\n/**\n * Convert given elements to an alternative.\n * This doesn't clone the array, so the return value is `elements` itself.\n * @param elements Elements to convert.\n */\nfunction elementsToAlternative(\n    elements: Element[],\n    parent: Disjunction,\n): AlternativeElement[] {\n    for (const element of elements) {\n        assert(element.type !== EnumTypeNode.Disjunction)\n        element.parent = parent\n    }\n    return elements as AlternativeElement[]\n}\n\nfunction addAlternativeElement(\n    parent:\n        | Pattern\n        | Disjunction\n        | Group\n        | CapturingGroup\n        | LookaroundAssertion,\n    node:\n        | Group\n        | CapturingGroup\n        | Quantifier\n        | CharacterClass\n        | Assertion\n        | AnyCharacterSet\n        | Backreference,\n): void {\n    if (parent.type === EnumTypeNode.Disjunction) {\n        last(parent.alternatives)!.push(node)\n    } else {\n        parent.elements.push(node)\n    }\n}\n\nfunction addCommonElement(\n    parent: AppendableNode,\n    node: EscapeCharacterSet | UnicodePropertyCharacterSet | Character,\n): void {\n    if (parent.type === EnumTypeNode.Disjunction) {\n        last(parent.alternatives)!.push(node)\n    } else if (parent.type === EnumTypeNode.CharacterClass) {\n        parent.elements.push(node)\n    } else {\n        parent.elements.push(node)\n    }\n}\n\nclass RegExpParserState {\n    readonly strict: boolean\n    readonly ecmaVersion: EnumEcmaVersion\n\n    readonly disableChkCharacterClassRange: boolean\n\n    private _node: AppendableNode = DummyPattern\n    private _flags: Flags = DummyFlags\n    private _disjunctionStartStack: number[] = []\n    private _backreferences: Backreference[] = []\n    private _capturingGroups: CapturingGroup[] = []\n\n    source: string = \"\"\n\n    constructor(options?: RegExpParser.Options) {\n        this.strict = Boolean(options && options.strict)\n        this.ecmaVersion = (options && options.ecmaVersion) || EnumEcmaVersion.v2018\n        this.disableChkCharacterClassRange = Boolean(options && options.disableChkCharacterClassRange)\n    }\n\n    get pattern(): Pattern {\n        if (this._node.type !== EnumTypeNode.Pattern) {\n            throw new Error(EnumError.UnknownError)\n        }\n        return this._node\n    }\n\n    get flags(): Flags {\n        if (this._flags.type !== EnumTypeNode.Flags) {\n            throw new Error(EnumError.UnknownError)\n        }\n        return this._flags\n    }\n\n    onFlags(\n        start: number,\n        end: number,\n        global: boolean,\n        ignoreCase: boolean,\n        multiline: boolean,\n        unicode: boolean,\n        sticky: boolean,\n        dotAll: boolean,\n    ): void {\n        this._flags = {\n            type: EnumTypeNode.Flags,\n            parent: null,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            global,\n            ignoreCase,\n            multiline,\n            unicode,\n            sticky,\n            dotAll,\n        }\n    }\n\n    onPatternEnter(start: number): void {\n        this._node = {\n            type: EnumTypeNode.Pattern,\n            parent: null,\n            start,\n            end: start,\n            raw: \"\",\n            elements: [],\n        }\n        this._backreferences.length = 0\n        this._capturingGroups.length = 0\n    }\n\n    onPatternLeave(start: number, end: number): void {\n        this._node.end = end\n        this._node.raw = this.source.slice(start, end)\n\n        for (const reference of this._backreferences) {\n            const ref = reference.ref\n            const group =\n                typeof ref === \"number\"\n                    ? this._capturingGroups[ref - 1]\n                    : this._capturingGroups.find(g => g.name === ref)!\n            reference.resolved = group\n            group.references.push(reference)\n        }\n    }\n\n    onDisjunctionEnter(start: number): void {\n        this._disjunctionStartStack.push(start)\n    }\n\n    onDisjunctionLeave(start: number, end: number): void {\n        this._disjunctionStartStack.pop()\n    }\n\n    onAlternativeEnter(start: number, index: number): void {\n        if (index === 0) {\n            return\n        }\n\n        const parentNode = this._node\n        if (\n            parentNode.type === EnumTypeNode.Disjunction ||\n            parentNode.type === EnumTypeNode.CharacterClass\n        ) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        const prevNode = last(parentNode.elements)\n        if (prevNode != null && prevNode.type === EnumTypeNode.Disjunction) {\n            this._node = prevNode\n            prevNode.alternatives.push([])\n        } else {\n            this._node = {\n                type: EnumTypeNode.Disjunction,\n                parent: parentNode,\n                start: last(this._disjunctionStartStack)!,\n                end: start,\n                raw: \"\",\n                alternatives: [],\n            }\n            const elements = elementsToAlternative(\n                parentNode.elements,\n                this._node,\n            )\n            this._node.alternatives.push(elements, [])\n            parentNode.elements = [this._node]\n        }\n    }\n\n    onAlternativeLeave(start: number, end: number, index: number): void {\n        if (index === 0) {\n            return\n        }\n        this._node.end = end\n        this._node.raw = this.source.slice(this._node.start, end)\n        this._node = this._node.parent as AppendableNode\n    }\n\n    onGroupEnter(start: number): void {\n        const parentNode = this._node\n        if (parentNode.type === EnumTypeNode.CharacterClass) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        this._node = {\n            type: EnumTypeNode.Group,\n            parent: parentNode,\n            start,\n            end: start,\n            raw: \"\",\n            elements: [],\n        }\n        addAlternativeElement(parentNode, this._node)\n    }\n\n    onGroupLeave(start: number, end: number): void {\n        this._node.end = end\n        this._node.raw = this.source.slice(start, end)\n        this._node = this._node.parent as AppendableNode\n    }\n\n    onCapturingGroupEnter(start: number, name: string | null): void {\n        const parentNode = this._node\n        if (parentNode.type === EnumTypeNode.CharacterClass) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        this._node = {\n            type: EnumTypeNode.CapturingGroup,\n            parent: parentNode,\n            start,\n            end: start,\n            raw: \"\",\n            name,\n            elements: [],\n            references: [],\n        }\n        addAlternativeElement(parentNode, this._node)\n        this._capturingGroups.push(this._node)\n    }\n\n    onCapturingGroupLeave(\n        start: number,\n        end: number,\n        name: string | null,\n    ): void {\n        this._node.end = end\n        this._node.raw = this.source.slice(start, end)\n        this._node = this._node.parent as AppendableNode\n    }\n\n    onQuantifier(\n        start: number,\n        end: number,\n        min: number,\n        max: number,\n        greedy: boolean,\n    ): void {\n        const parentNode = this._node\n        if (parentNode.type === EnumTypeNode.CharacterClass) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        // Replace the last element.\n        const elements =\n            parentNode.type === EnumTypeNode.Disjunction\n                ? last(parentNode.alternatives)!\n                : parentNode.elements\n        const prevNode = elements.pop()!\n        const node: Quantifier = {\n            type: EnumTypeNode.Quantifier,\n            parent: parentNode,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            min,\n            max,\n            greedy,\n            element: prevNode as QuantifiableElement,\n        }\n        elements.push(node)\n        prevNode.parent = node\n    }\n\n    onLookaroundAssertionEnter(\n        start: number,\n        kind: EnumKindAssertion.LookaheadAssertion | EnumKindAssertion.LookbehindAssertion,\n        negate: boolean,\n    ): void {\n        const parentNode = this._node\n        if (parentNode.type === EnumTypeNode.CharacterClass) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        this._node = {\n            type: EnumTypeNode.Assertion,\n            parent: parentNode,\n            start,\n            end: start,\n            raw: \"\",\n            kind,\n            negate,\n            elements: [],\n        } as LookaroundAssertion\n        addAlternativeElement(parentNode, this._node)\n    }\n\n    onLookaroundAssertionLeave(\n        start: number,\n        end: number,\n        kind: EnumKindLookAssertion,\n        negate: boolean,\n    ): void {\n        this._node.end = end\n        this._node.raw = this.source.slice(start, end)\n        this._node = this._node.parent as AppendableNode\n    }\n\n    onEdgeAssertion(start: number, end: number, kind: EnumKindEdgeAssertion): void {\n        const parentNode = this._node\n        if (parentNode.type === EnumTypeNode.CharacterClass) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        addAlternativeElement(parentNode, {\n            type: EnumTypeNode.EdgeAssertion,\n            parent: parentNode,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n        })\n    }\n\n    onWordBoundaryAssertion(\n        start: number,\n        end: number,\n        kind: EnumKindAssertion.WordBoundaryAssertion,\n        negate: boolean,\n    ): void {\n        const parentNode = this._node\n        if (parentNode.type === EnumTypeNode.CharacterClass) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        addAlternativeElement(parentNode, {\n            type: EnumTypeNode.WordBoundaryAssertion,\n            parent: parentNode,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n            negate,\n        })\n    }\n\n    onAnyCharacterSet(start: number, end: number, kind: EnumKindCharacterSet.AnyCharacterSet): void {\n        const parentNode = this._node\n        if (parentNode.type === EnumTypeNode.CharacterClass) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        addAlternativeElement(parentNode, {\n            type: EnumTypeNode.AnyCharacterSet,\n            parent: parentNode,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n        })\n    }\n\n    onEscapeCharacterSet(\n        start: number,\n        end: number,\n        kind: EnumKindEscapeCharacterSet,\n        negate: boolean,\n    ): void {\n        addCommonElement(this._node, {\n            type: EnumTypeNode.EscapeCharacterSet,\n            parent: this._node,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n            negate,\n        })\n    }\n\n    onUnicodePropertyCharacterSet(\n        start: number,\n        end: number,\n        kind: EnumKindCharacterSet.UnicodePropertyCharacterSet,\n        key: string,\n        value: string | null,\n        negate: boolean,\n    ): void {\n        addCommonElement(this._node, {\n            type: EnumTypeNode.UnicodePropertyCharacterSet,\n            parent: this._node,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n            key,\n            value,\n            negate,\n        })\n    }\n\n    onCharacter(start: number, end: number, value: number): void {\n        addCommonElement(this._node, {\n            type: EnumTypeNode.Character,\n            parent: this._node,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            value,\n        })\n    }\n\n    onBackreference(start: number, end: number, ref: number | string): void {\n        const parentNode = this._node\n        if (parentNode.type === EnumTypeNode.CharacterClass) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        const node: Backreference = {\n            type: EnumTypeNode.Backreference,\n            parent: parentNode,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            ref,\n            resolved: DummyCapturingGroup,\n        }\n        addAlternativeElement(parentNode, node)\n        this._backreferences.push(node)\n    }\n\n    onCharacterClassEnter(start: number, negate: boolean): void {\n        const parentNode = this._node\n        if (parentNode.type === EnumTypeNode.CharacterClass) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        this._node = {\n            type: EnumTypeNode.CharacterClass,\n            parent: parentNode,\n            start,\n            end: start,\n            raw: \"\",\n            negate,\n            elements: [],\n        }\n        addAlternativeElement(parentNode, this._node)\n    }\n\n    onCharacterClassLeave(start: number, end: number, negate: boolean): void {\n        this._node.end = end\n        this._node.raw = this.source.slice(start, end)\n        this._node = this._node.parent as AppendableNode\n    }\n\n    onCharacterClassRange(\n        start: number,\n        end: number,\n        min: number,\n        max: number,\n    ): void {\n        const parentNode = this._node\n        if (parentNode.type !== EnumTypeNode.CharacterClass) {\n            throw new Error(EnumError.UnknownError)\n        }\n\n        // Replace the last three elements.\n        const elements = parentNode.elements\n        const rightNode = elements.pop() as Character\n        elements.pop() // hyphen\n        const leftNode = elements.pop() as Character\n        const node: CharacterClassRange = {\n            type: EnumTypeNode.CharacterClassRange,\n            parent: parentNode,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            min: leftNode,\n            max: rightNode,\n        }\n        assert(leftNode != null && leftNode.type === EnumTypeNode.Character)\n        assert(rightNode != null && rightNode.type === EnumTypeNode.Character)\n        leftNode.parent = node\n        rightNode.parent = node\n        elements.push(node)\n    }\n}\n\nexport namespace RegExpParser {\n    /**\n     * The options for RegExpParser construction.\n     */\n    export interface Options {\n        /**\n         * The flag to disable Annex B syntax. Default is `false`.\n         */\n        strict?: boolean\n\n        /**\n         * ECMAScript version. Default is `2018`.\n         * - `2015` added `u` and `y` flags.\n         * - `2018` added `s` flag, Named Capturing Group, Lookbehind Assertion,\n         *   and Unicode Property Escape.\n         */\n        ecmaVersion?: EnumEcmaVersion\n\n        disableChkCharacterClassRange?: boolean\n    }\n}\n\nexport class RegExpParser {\n    private _state: RegExpParserState\n    private _validator: RegExpValidator\n\n    /**\n     * Initialize this parser.\n     * @param options The options of parser.\n     */\n    constructor(options?: RegExpParser.Options) {\n        this._state = new RegExpParserState(options)\n        this._validator = new RegExpValidator(this._state)\n    }\n\n    /**\n     * Parse a regular expression literal. E.g. \"/abc/g\"\n     * @param source The source code to parse.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     * @returns The AST of the given regular expression.\n     */\n    parseLiteral(\n        source: string,\n        start: number = 0,\n        end: number = source.length,\n    ): RegExpLiteral {\n        this._state.source = source\n        this._validator.validateLiteral(source, start, end)\n        const pattern = this._state.pattern\n        const flags = this._state.flags\n        const literal: RegExpLiteral = {\n            type: EnumTypeNode.RegExpLiteral,\n            parent: null,\n            start,\n            end,\n            raw: source,\n            pattern,\n            flags,\n        }\n        pattern.parent = literal\n        flags.parent = literal\n        return literal\n    }\n\n    /**\n     * Parse a regular expression flags. E.g. \"gim\"\n     * @param source The source code to parse.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     * @returns The AST of the given flags.\n     */\n    parseFlags(\n        source: string,\n        start: number = 0,\n        end: number = source.length,\n    ): Flags {\n        this._state.source = source\n        this._validator.validateFlags(source, start, end)\n        return this._state.flags\n    }\n\n    /**\n     * Parse a regular expression pattern. E.g. \"abc\"\n     * @param source The source code to parse.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     * @param uFlag The flag to set unicode mode.\n     * @returns The AST of the given pattern.\n     */\n    parsePattern(\n        source: string,\n        start: number = 0,\n        end: number = source.length,\n        uFlag: boolean = false,\n    ): Pattern {\n        this._state.source = source\n        this._validator.validatePattern(source, start, end, uFlag)\n        return this._state.pattern\n    }\n}\n"]}