{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";AAAA;;GAEG;;;AAEH,mDAAoE;AAKvD,QAAA,eAAe,GAAG,IAAI,MAAM,CAAC,IAAI,wBAAO,CAAC,WAAW,GAAG,EAAE,GAAG,CAAC,CAAC;AAC9D,QAAA,mBAAmB,GAAG,IAAI,MAAM,CAAC,KAAK,wBAAO,CAAC,WAAW,GAAG,EAAE,GAAG,CAAC,CAAC;AAEnE,QAAA,YAAY,GAAG,wBAAO,CAAC,SAAS,CAAC,KAAK,CAAC;AAIpD,SAAgB,cAAc,CAAC,MAAM;IAEpC,IAAI,KAAa,CAAC;IAElB,IAAI,MAAM,YAAY,MAAM,EAC5B,CAAC;QACA,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC,CAAA;IACjC,CAAC;IAED,IAAI,OAAO,MAAM,KAAK,QAAQ,EAC9B,CAAC;QACA,KAAK,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC;IACrC,CAAC;SAED,CAAC;QACA,MAAM,IAAI,SAAS,CAAC,iCAAiC,CAAC,CAAC;IACxD,CAAC;IAED,OAAO,KAAK,CAAC;AACd,CAAC;AAnBD,wCAmBC;AAED,SAAgB,mBAAmB,CAAC,KAAa;IAEhD,OAAO,KAAK,CAAC,OAAO,CAAC,2BAAmB,EAAE,EAAE,CAAC,CAAC;AAC/C,CAAC;AAHD,kDAGC;AAED,SAAgB,aAAa,CAAC,KAAa;IAE1C,OAAO,CAAC,KAAK,KAAK,EAAE,CAAC,IAAI,CAAC,2BAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC3D,CAAC;AAHD,sCAGC;AAED;;;;;;GAMG;AACH,SAAgB,eAAe,CAAmB,KAAQ;IAEzD,OAAO,oBAAY,CAAC,CAAC;QACpB,KAAK,CAAC,KAAK,CAAC,CAAC;QACb,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAC5D;AACH,CAAC;AAND,0CAMC;AAeD,SAAgB,qBAAqB,CAAoE,WAAc,EACtH,UAAa,0BAAgB;IAG7B,OAAO,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;SACzB,MAAM,CAAC,UAAU,CAAC,EAAE,IAAI;QAExB,IAAK,WAAmB,CAAC,IAAI,CAAC,KAAK,IAAI;eACnC,CAAC,IAAI,IAAI,OAAO,CAAC;eACjB,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAErC,CAAC;YACA,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;QACvB,CAAC;QAED,OAAO,CAAC,CAAC;IACV,CAAC,EAAE,EAAoB,CAAC;SACvB,IAAI,EAAE,CACP;AACF,CAAC;AAnBD,sDAmBC;AAED,SAAgB,gBAAgB,CAAoE,WAAc,EACjH,UAAa,0BAAgB;IAG7B,OAAO,qBAAqB,CAAC,WAAW,EAAE,OAAO,CAAC;SAChD,IAAI,CAAC,EAAE,CAAC,CACR;AACH,CAAC;AAPD,4CAOC;AAED,kBAAe,OAAmC,CAAC","sourcesContent":["/**\n * Created by user on 2018/4/28/028.\n */\n\nimport { support, hasSupportFlag, FlagsName } from 'regexp-support';\nimport { ITSPickByType, ITSKeyofByExtractType } from 'ts-type/lib/helper/record/pick-type';\nimport { ITSValueOf } from 'ts-type/lib/helper/key-value';\nimport { ITSTypeAndStringLiteral } from 'ts-type/lib/helper/string';\n\nexport const RE_NATIVE_FLAGS = new RegExp(`[${support.nativeFlags}]`, 'g');\nexport const RE_NON_NATIVE_FLAGS = new RegExp(`[^${support.nativeFlags}]`, 'g');\n\nexport const hasFlagsProp = support.prototype.flags;\n\nexport function getNativeFlags<T extends RegExp>(target: T): string\nexport function getNativeFlags(target: string): string\nexport function getNativeFlags(target): string\n{\n\tlet flags: string;\n\n\tif (target instanceof RegExp)\n\t{\n\t\ttarget = _getNativeFlags(target)\n\t}\n\n\tif (typeof target === 'string')\n\t{\n\t\tflags = stripNonNativeFlags(target);\n\t}\n\telse\n\t{\n\t\tthrow new TypeError(`target must is RegExp or String`);\n\t}\n\n\treturn flags;\n}\n\nexport function stripNonNativeFlags(flags: string)\n{\n\treturn flags.replace(RE_NON_NATIVE_FLAGS, '');\n}\n\nexport function isNativeFlags(flags: string)\n{\n\treturn (flags === '') || !RE_NON_NATIVE_FLAGS.test(flags);\n}\n\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {String} Native flags in use.\n */\nexport function _getNativeFlags<T extends RegExp>(regex: T)\n{\n\treturn hasFlagsProp ?\n\t\tregex.flags :\n\t\t/\\/([a-z]*)$/i.exec(RegExp.prototype.toString.call(regex))[1]\n\t\t;\n}\n\nexport type IFlag = ITSTypeAndStringLiteral<FlagsName>\n\nexport type IFlagPrototype = {\n\t[P in ITSKeyofByExtractType<typeof FlagsName, IFlag>]?: boolean;\n}\nexport type IFlagMap = Partial<ITSPickByType<typeof FlagsName, IFlag>>\n\nexport type IFlagPrototypeInput = IFlagPrototype | Record<string, boolean>;\nexport type IFlagMapInput = IFlagMap | Record<string, string>\n\nexport type IFlagsValue<R extends IFlagMapInput> = ITSValueOf<ITSPickByType<R, string | IFlag>>\nexport type IFlagsArray<R extends IFlagMapInput> = IFlagsValue<R>[]\n\nexport function prototypeToFlagsArray<T extends IFlagPrototypeInput, R extends IFlagMapInput = IFlagMap>(inputObject: T,\n\tflagMap: R = FlagsName as any\n): IFlagsArray<R>\n{\n\treturn Object.keys(flagMap)\n\t\t.reduce(function (a, name)\n\t\t{\n\t\t\tif ((inputObject as any)[name] === true\n\t\t\t\t&& (name in flagMap)\n\t\t\t\t&& (a.indexOf(flagMap[name]) === -1)\n\t\t\t)\n\t\t\t{\n\t\t\t\ta.push(flagMap[name]);\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}, [] as IFlagsArray<R>)\n\t\t.sort()\n\t;\n}\n\nexport function prototypeToFlags<T extends IFlagPrototypeInput, R extends IFlagMapInput = IFlagMap>(inputObject: T,\n\tflagMap: R = FlagsName as any\n): string | IFlagsValue<R>\n{\n\treturn prototypeToFlagsArray(inputObject, flagMap)\n\t\t.join('')\n\t\t;\n}\n\nexport default exports as typeof import('./index');\n"]}