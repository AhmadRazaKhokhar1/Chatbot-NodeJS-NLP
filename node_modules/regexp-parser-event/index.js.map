{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import { AST } from \"regexpp2\";\n//import * as regexpp from 'regexpp2';\nimport { EventEmitter } from 'events';\nimport { array_unique } from 'array-hyper-unique';\nimport { ITSPartialRecord, ITSOverwrite } from 'ts-type';\n\nimport Parser, {\n\tastToString,\n\tfakePatternToRegExpLiteral,\n\tparseFlags,\n\tparsePattern,\n\tINodePlus,\n\tIAstToStringOptions,\n} from 'regexp-parser-literal';\n\nimport { AppendableNode } from 'regexpp2/src/parser';\n\nexport const enum ParserEventEmitterEvent\n{\n\tdefault = 'default',\n\tclass = 'class',\n\n\tother = 'other',\n\n\tuniset = 'uniset',\n\n\tclass_default = 'class_default',\n\tclass_range = 'class_range',\n\tclass_other = 'class_other',\n\n\tclass_uniset = 'class_uniset',\n\n\tchange = 'change',\n}\n\n// @ts-ignore\nexport const ParserEventEmitterEventList = Object.freeze(array_unique(Object.values(ParserEventEmitterEvent))) as ParserEventEmitterEvent[];\n\nexport type INodeInput = AST.Element | AST.CharacterClassElement | AppendableNode | AST.CharacterSet;\n\nexport class ParserEventEmitter extends EventEmitter\n{\n\tastRegExpLiteral: AST.RegExpLiteral & INodePlus = null;\n\n\tconstructor(inputAst: AST.Pattern | AST.RegExpLiteral | string, flags: string | AST.Flags = '')\n\t{\n\t\tsuper();\n\n\t\tconst self = this;\n\n\t\tif (typeof inputAst == 'string' || inputAst.type == 'Pattern')\n\t\t{\n\t\t\tinputAst = fakePatternToRegExpLiteral(inputAst, flags);\n\t\t}\n\n\t\tthis.astRegExpLiteral = inputAst as AST.RegExpLiteral;\n\n\t\tthis.on(ParserEventEmitterEvent.change, function (ast)\n\t\t{\n\t\t\tself._change(ast, true);\n\t\t\tself.changed = true;\n\t\t});\n\n//\t\tconsole.dir(this.astRegExpLiteral.pattern.elements, {\n//\t\t\tcolors: true,\n//\t\t\tdepth: 3,\n//\t\t});\n\t}\n\n\tstatic create(inputAst: AST.Pattern | AST.RegExpLiteral | string, flags: string | AST.Flags = '')\n\t{\n\t\treturn new this(inputAst, flags);\n\t}\n\n\tresume()\n\t{\n\t\tconst self = this;\n\n\t\t/*\n\t\t0 && console.dir(this.astRegExpLiteral.pattern, {\n\t\t\tdepth: null,\n\t\t\tcolors: true,\n\t\t});\n\t\t*/\n\n\t\tlet pattern = this.astRegExpLiteral.pattern;\n\n\t\t// @ts-ignore\n\t\tlet elems = pattern.alternatives || pattern.elements;\n\n\t\telems.forEach(function (item)\n\t\t{\n\t\t\tself._lookup_sub(item, self);\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * same as this.emit(ParserEventEmitterEvent.change, ast)\n\t */\n\temitChange<T extends INodeInput>(inputAst: T & INodePlus, ...args)\n\t{\n\t\treturn this.emit(ParserEventEmitterEvent.change, inputAst, ...args)\n\t}\n\n\toverride emit<T extends INodeInput>(eventName: ParserEventEmitterEvent,\n\t\tinputAst: T & INodePlus,\n\t\t...args\n\t): boolean\n\t{\n\t\treturn (super.emit as IParserEventEmitterListenerSuper<T, ParserEventEmitterEvent>)(eventName, inputAst, eventName, this, ...args);\n\t}\n\n\toverride on<E extends ParserEventEmitterEvent.default>(eventName: E,\n\t\tlistener: IParserEventEmitterListener<AST.Character, E>,\n\t): this\n\toverride on<E extends ParserEventEmitterEvent.class>(eventName: E,\n\t\tlistener: IParserEventEmitterListener<AST.CharacterClass, E>,\n\t): this\n\toverride on<E extends ParserEventEmitterEvent.class_default>(eventName: E,\n\t\tlistener: IParserEventEmitterListener<AST.Character, E>,\n\t): this\n\toverride on<E extends ParserEventEmitterEvent.class_range>(eventName: E,\n\t\tlistener: IParserEventEmitterListener<AST.CharacterClassRange, E>,\n\t): this\n\toverride on<E extends ParserEventEmitterEvent.other>(eventName: E,\n\t\tlistener: IParserEventEmitterListener<AST.CharacterClassElement, E>,\n\t): this\n\toverride on<E extends ParserEventEmitterEvent.uniset>(eventName: E,\n\t\tlistener: IParserEventEmitterListener<AST.CharacterSet, E>,\n\t): this\n\toverride on<E extends ParserEventEmitterEvent>(eventName: ParserEventEmitterEvent,\n\t\tlistener: IParserEventEmitterListener<AST.Element, E>,\n\t): this\n\toverride on(eventName: ParserEventEmitterEvent, listener: IParserEventEmitterListener<any, ParserEventEmitterEvent>): this\n\t{\n\t\treturn super.on(eventName, listener);\n\t}\n\n\tprotected _change<T extends AST.Node>(ast: T & INodePlus, isFirst?: boolean)\n\t{\n\t\tconst self = this;\n\n\t\tast.changed = true;\n\n\t\tif (ast.parent)\n\t\t{\n\t\t\tthis._change(ast.parent)\n\t\t}\n\t}\n\n\tprotected _lookup_sub<T extends INodeInput>(inputAst: T & INodePlus,\n\t\tmyEmitter: ParserEventEmitter,\n\t\tparent?,\n\t\teventPrefix: string = '',\n\t)\n\t{\n\t\tconst self = this;\n\n\t\tlet do_elements: boolean;\n\t\tlet sub_elements: any[];\n\t\tlet sub_prefix: string = '';\n\t\tlet event: string | keyof typeof ParserEventEmitterEvent | ParserEventEmitterEvent;\n\n\t\tswitch (inputAst.type)\n\t\t{\n\t\t\tcase 'Character':\n\t\t\t\tevent = eventPrefix + ParserEventEmitterEvent.default;\n\n\t\t\t\tbreak;\n\t\t\tcase 'CharacterClass':\n\t\t\t\tevent = ParserEventEmitterEvent.class;\n\n\t\t\t\tdo_elements = true;\n\t\t\t\tsub_prefix = 'class_';\n\n\t\t\t\tbreak;\n\t\t\tcase 'CharacterClassRange':\n\t\t\t\tevent = ParserEventEmitterEvent.class_range;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'CharacterSet':\n\t\t\t\tevent = eventPrefix + ParserEventEmitterEvent.uniset;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Quantifier':\n\n\t\t\t\tdo_elements = true;\n\t\t\t\t// @ts-ignore\n\t\t\t\tsub_elements = [inputAst.element];\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'CapturingGroup':\n\t\t\tcase 'Group':\n\t\t\tcase 'Assertion':\n\t\t\t\tdo_elements = true;\n\t\t\t\tbreak;\n\n\t\t\t// @ts-ignore\n\t\t\tcase 'Alternative':\n\n\t\t\t\t// @ts-ignore\n\t\t\t\t(inputAst as AST.Alternative).elements\n\t\t\t\t\t.forEach(function (items)\n\t\t\t\t\t{\n\t\t\t\t\t\tself._lookup_sub(items, myEmitter, inputAst, sub_prefix);\n\t\t\t\t\t});\n\t\t\t\t;\n\n\t\t\t\tbreak;\n\n\t\t\t// @ts-ignore\n\t\t\tcase 'Disjunction':\n\n\t\t\t\t// @ts-ignore\n\t\t\t\t(inputAst as AST.Disjunction).alternatives\n\t\t\t\t\t.forEach(function (items)\n\t\t\t\t\t{\n\t\t\t\t\t\titems.forEach(function (item)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tself._lookup_sub(item, myEmitter, inputAst, sub_prefix);\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif (eventPrefix === 'class_')\n\t\t\t\t{\n\t\t\t\t\tevent = ParserEventEmitterEvent.class_other;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tevent = eventPrefix + ParserEventEmitterEvent.other;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (event)\n\t\t{\n\t\t\t// @ts-ignore\n\t\t\tmyEmitter.emit(ParserEventEmitterEvent[event], inputAst);\n\t\t}\n\n\t\tif (do_elements && typeof sub_elements == 'undefined')\n\t\t{\n\t\t\t// @ts-ignore\n\t\t\tsub_elements = inputAst.elements;\n\n\t\t\tif (typeof sub_elements == 'undefined')\n\t\t\t{\n\t\t\t\t// @ts-ignore\n\t\t\t\tsub_elements = inputAst.alternatives;\n\t\t\t}\n\t\t}\n\n\t\tif (!inputAst.type)\n\t\t{\n\t\t\t//console.log(inputAst.type, sub_elements && sub_elements.length, inputAst);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//console.log(inputAst.type, sub_elements && sub_elements.length);\n\t\t}\n\n\t\t// @ts-ignore\n\t\tif (do_elements && sub_elements)\n\t\t{\n\t\t\t// @ts-ignore\n\t\t\tsub_elements.forEach(function (item)\n\t\t\t{\n\t\t\t\tself._lookup_sub(item, myEmitter, inputAst, sub_prefix);\n\t\t\t});\n\t\t}\n\t}\n\n\tgetSource(overwrite?: boolean, options?: IAstToStringOptions): string\n\t{\n\t\treturn astToString(this.astRegExpLiteral.pattern, {\n\n\t\t\t...options,\n\n\t\t\t// @ts-ignore\n\t\t\tdebugChanged: overwrite ? 99 : this.astRegExpLiteral.pattern.changed,\n\t\t});\n\t}\n\n\tgetFlags(overwrite?: boolean, options?: IAstToStringOptions): string\n\t{\n\t\treturn astToString(this.astRegExpLiteral.flags, {\n\n\t\t\t...options,\n\n\t\t\t// @ts-ignore\n\t\t\tdebugChanged: overwrite ? 99 : this.astRegExpLiteral.flags.changed,\n\t\t});\n\t}\n\n\t// @ts-ignore\n\tget source(): string\n\t{\n\t\treturn this.getSource();\n\t}\n\n\t// @ts-ignore\n\tset source(pattern: AST.Pattern | string)\n\t{\n\t\tpattern = typeof pattern == 'string' ? parsePattern(pattern, this.astRegExpLiteral.flags.unicode) : pattern;\n\n\t\tpattern.parent = this.astRegExpLiteral;\n\n\t\tthis.astRegExpLiteral.pattern = pattern;\n\n\t\tthis.changed = false;\n\t}\n\n\t// @ts-ignore\n\tget flags(): string\n\t{\n\t\treturn this.getFlags();\n\t}\n\n\t// @ts-ignore\n\tset flags(flags: string | AST.Flags)\n\t{\n\t\tflags = typeof flags == 'string' ? parseFlags(flags) : flags;\n\n\t\tflags.parent = this.astRegExpLiteral;\n\n\t\tthis.astRegExpLiteral.flags = flags;\n\n\t\t// @ts-ignore\n\t\tthis.changed = this.astRegExpLiteral.pattern.changed || false;\n\t}\n\n\tget changed()\n\t{\n\t\treturn this.astRegExpLiteral.changed\n\t\t// @ts-ignore\n\t\t|| this.astRegExpLiteral.pattern.changed\n\t\t|| typeof this.astRegExpLiteral.changed == 'boolean' ? this.astRegExpLiteral.changed : null;\n\t}\n\n\tset changed(bool: boolean)\n\t{\n\t\t// @ts-ignore\n\t\tthis.astRegExpLiteral.pattern.changed = this.astRegExpLiteral.changed = bool;\n\t}\n\n\toverride toString(overwrite?: boolean, options?: IAstToStringOptions)\n\t{\n\t\treturn astToString(this.astRegExpLiteral, {\n\n\t\t\t...options,\n\n\t\t\tdebugChanged: overwrite ? 99 : this.changed,\n\t\t});\n\t}\n\n\ttoRegExp<T extends RegExp>(RegExpClass: typeof RegExp = RegExp)\n\t{\n\t\treturn new RegExpClass(this.source, this.flags);\n\t}\n\n\t/**\n\t * this will not update changes\n\t */\n\tget astSource()\n\t{\n\t\treturn this.astRegExpLiteral.pattern;\n\t}\n\n\t/**\n\t * this will not update changes\n\t */\n\tget astFlags()\n\t{\n\t\treturn this.astRegExpLiteral.flags;\n\t}\n\n}\n\nexport interface IParserEventEmitterListenerMap<T extends INodeInput = INodeInput> extends ITSOverwrite<ITSPartialRecord<ParserEventEmitterEvent, IParserEventEmitterListener<any, ParserEventEmitterEvent>>,\n{\n\t/**\n\t * 一般性 文字 節點\n\t */\n\t[ParserEventEmitterEvent.default]?: IParserEventEmitterListener<AST.Character, ParserEventEmitterEvent.default>;\n\n\t/**\n\t * /[xxx]/ 這類\n\t */\n\t[ParserEventEmitterEvent.class]?: IParserEventEmitterListener<AST.CharacterClass, ParserEventEmitterEvent.class>;\n\n\t/**\n\t * /[xxx]/ 之中的 xxx\n\t */\n\t[ParserEventEmitterEvent.class_default]?: IParserEventEmitterListener<AST.Character, ParserEventEmitterEvent.class_default>;\n\n\t/**\n\t * /[0-9]/ 之中的 0-9\n\t */\n\t[ParserEventEmitterEvent.class_range]?: IParserEventEmitterListener<AST.CharacterClassRange, ParserEventEmitterEvent.class_range>;\n\n\t/**\n\t * /[\\p{xxxx}]/ 之中的 \\p{xxxx}\n\t */\n\t[ParserEventEmitterEvent.class_uniset]?: IParserEventEmitterListener<AST.CharacterSet, ParserEventEmitterEvent.class_uniset>;\n\n\t[ParserEventEmitterEvent.other]?: IParserEventEmitterListener<AST.CharacterClassElement, ParserEventEmitterEvent.other>;\n\n\t/**\n\t * \\p{xxxx}\n\t */\n\t[ParserEventEmitterEvent.uniset]?: IParserEventEmitterListener<AST.CharacterSet, ParserEventEmitterEvent.uniset>;\n}>\n{\n\n}\n\nexport interface IParserEventEmitterListener<T extends INodeInput, E extends keyof typeof ParserEventEmitterEvent>\n{\n\t(inputAst: T & INodePlus, eventName: E, emitter: ParserEventEmitter, ...argv: unknown[])\n}\n\ninterface IParserEventEmitterListenerSuper<T extends INodeInput, E extends keyof typeof ParserEventEmitterEvent>\n{\n\t(event: E, inputAst: T & INodePlus, eventName: E, emitter: ParserEventEmitter, ...argv: unknown[]): boolean\n}\n\nexport default ParserEventEmitter;\n"]}