{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";AAAA;;GAEG;;;AAIH,mCAAmC;AAsBnC,MAAsB,qBAAqB;IAU1C,YAAY,IAAY,EAAE,UAAoB,EAAE,EAAE,WAAsC,EAAE,GAAG,IAAI;QAL1F,UAAK,GAAa,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACtC,WAAM,GAAoB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAMpD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QAEjB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAExD,IAAI,WAAW,EACf;YACC,IAAI,WAAW,CAAC,KAAK,EACrB;gBACC,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC;aAC/B;YAED,IAAI,WAAW,CAAC,MAAM,EACtB;gBACC,IAAI,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;aACjC;SACD;QAED,IAAI,CAAC,KAAK,EAAE,CAAC;IACd,CAAC;IAED,KAAK;QAEJ,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QACxC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IAC1C,CAAC;IAES,OAAO,CAAsC,IAAO,EAAE,GAAG,IAAI;QAEtE,IAAI,CAAS,CAAC;QAEd,IAAI,OAAO,IAAI,KAAK,QAAQ,EAC5B;YACC,CAAC,GAAG,IAAI,CAAC;SACT;aACI,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAC5B;YACC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SACX;aAED;YACC,CAAC,EAAE,CAAC,EAAE,GAAG,IAAa,CAAC,CAAC;SACxB;QAED,OAAO,CAAC,CAAA;IACT,CAAC;IAEM,MAAM,CAAsC,IAAO,EAAE,GAAG,IAAI;QAElE,MAAM,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAE7B,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC;IAC9B,CAAC;IASM,IAAI,CAAC,GAAG,IAAI;QAElB,OAAO,IAAA,kBAAS,EAAC,IAAI,CAAC,KAAK,CAAC,CAAA;IAC7B,CAAC;IAGM,IAAI;QAEV,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC;IACvC,CAAC;CACD;AAlFD,sDAkFC;AAED,kBAAe,qBAAqB,CAAC","sourcesContent":["/**\n * Created by user on 2018/4/19/019.\n */\n\nimport { IDictRow } from '@novel-segment/loaders/segment/index';\nimport { IWord } from '@novel-segment/types';\nimport { cloneDeep } from 'lodash';\n\nexport type IOptions = {\n\tautoCjk?: boolean,\n}\n\nexport interface IDICT<T = any>\n{\n\t[key: string]: T,\n}\n\nexport interface IDICT2<T = any>\n{\n\t[key: number]: IDICT<T>,\n}\n\nexport interface ITableDictExistsTable<T>\n{\n\tTABLE?: IDICT<T>,\n\tTABLE2?: any | IDICT2<T>,\n}\n\nexport abstract class AbstractTableDictCore<T>\n{\n\tpublic static type: string;\n\tpublic type: string;\n\n\tpublic TABLE: IDICT<T> = Object.create(null);\n\tpublic TABLE2: any | IDICT2<T> = Object.create(null);\n\n\tpublic options: IOptions;\n\n\tconstructor(type: string, options: IOptions = {}, existsTable?: ITableDictExistsTable<T>, ...argv)\n\t{\n\t\tthis.type = type;\n\n\t\tthis.options = Object.assign({}, this.options, options);\n\n\t\tif (existsTable)\n\t\t{\n\t\t\tif (existsTable.TABLE)\n\t\t\t{\n\t\t\t\tthis.TABLE = existsTable.TABLE;\n\t\t\t}\n\n\t\t\tif (existsTable.TABLE2)\n\t\t\t{\n\t\t\t\tthis.TABLE2 = existsTable.TABLE2;\n\t\t\t}\n\t\t}\n\n\t\tthis._init();\n\t}\n\n\t_init()\n\t{\n\t\tObject.setPrototypeOf(this.TABLE, null);\n\t\tObject.setPrototypeOf(this.TABLE2, null);\n\t}\n\n\tprotected _exists<U extends IWord | IDictRow | string>(data: U, ...argv)\n\t{\n\t\tlet w: string;\n\n\t\tif (typeof data === 'string')\n\t\t{\n\t\t\tw = data;\n\t\t}\n\t\telse if (Array.isArray(data))\n\t\t{\n\t\t\t[w] = data;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t({ w } = data as IWord);\n\t\t}\n\n\t\treturn w\n\t}\n\n\tpublic exists<U extends IWord | IDictRow | string>(data: U, ...argv)\n\t{\n\t\tconst w = this._exists(data);\n\n\t\treturn this.TABLE[w] || null;\n\t}\n\n\tpublic abstract add(data, ...argv): this\n\n\tprotected abstract _add(data, ...argv)\n\n\tpublic remove?(data, ...argv): this\n\tprotected _remove?(data, ...argv)\n\n\tpublic json(...argv): IDICT<T>\n\t{\n\t\treturn cloneDeep(this.TABLE)\n\t}\n\tpublic stringify?(...argv): string\n\n\tpublic size(): number\n\t{\n\t\treturn Object.keys(this.TABLE).length;\n\t}\n}\n\nexport default AbstractTableDictCore;\n"]}