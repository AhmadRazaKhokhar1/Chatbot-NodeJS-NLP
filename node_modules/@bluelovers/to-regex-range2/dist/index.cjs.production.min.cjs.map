{"version":3,"file":"index.cjs.production.min.cjs","sources":["../src/index.ts","../src/index.cts"],"sourcesContent":["/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nimport { isUnSafeNumLike as isNumber } from '@lazy-assert/check-basic';\n\nexport interface IOptions\n{\n\t/**\n\t * Wrap the returned value in parentheses when there is more than one regex condition. Useful when you're dynamically generating ranges.\n\t *\n\t * @example\n\t * console.log(toRegexRange('-10', '10'));\n\t * //=> -[1-9]|-?10|[0-9]\n\t *\n\t * console.log(toRegexRange('-10', '10', { capture: true }));\n\t * //=> (-[1-9]|-?10|[0-9])\n\t */\n\tcapture?: boolean,\n\t/**\n\t * Use the regex shorthand for [0-9]:\n\t *\n\t * @example\n\t * console.log(toRegexRange('0', '999999'));\n\t * //=> [0-9]|[1-9][0-9]{1,5}\n\t *\n\t * console.log(toRegexRange('0', '999999', { shorthand: true }));\n\t * //=> \\d|[1-9]\\d{1,5}\n\t */\n\tshorthand?: boolean,\n\t/**\n\t * @default true\n\t * This option relaxes matching for leading zeros when when ranges are zero-padded.\n\t * @example\n\t * const source = toRegexRange('-0010', '0010');\n\t * const regex = new RegExp(`^${source}$`);\n\t * console.log(regex.test('-10')); //=> true\n\t * console.log(regex.test('-010')); //=> true\n\t * console.log(regex.test('-0010')); //=> true\n\t * console.log(regex.test('10')); //=> true\n\t * console.log(regex.test('010')); //=> true\n\t * console.log(regex.test('0010')); //=> true\n\t * @example When `relaxZeros` is false, matching is strict:\n\t * const source = toRegexRange('-0010', '0010', { relaxZeros: false });\n\t * const regex = new RegExp(`^${source}$`);\n\t * console.log(regex.test('-10')); //=> false\n\t * console.log(regex.test('-010')); //=> false\n\t * console.log(regex.test('-0010')); //=> true\n\t * console.log(regex.test('10')); //=> false\n\t * console.log(regex.test('010')); //=> false\n\t * console.log(regex.test('0010')); //=> true\n\t */\n\trelaxZeros?: boolean,\n\n\tstrictZeros?: boolean,\n\twrap?: boolean,\n}\n\nexport const SymCache = Symbol.for('SymCache');\n\nfunction isAllowedValue(value: unknown)\n{\n\tif (isNumber(value) === true)\n\t{\n\t\tif (typeof value === 'string')\n\t\t{\n\t\t\treturn /^-?\\d+$/.test(value);\n\t\t}\n\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nexport function toRegexRange(min: number | string, max?: number | string, options?: IOptions): string\n{\n\tif (!isAllowedValue(min))\n\t{\n\t\tthrow new TypeError(`toRegexRange: expected the first argument '${min}' to be a number like.`);\n\t}\n\n\tif (max === void 0 || min === max)\n\t{\n\t\treturn String(min);\n\t}\n\n\tif (!isAllowedValue(max))\n\t{\n\t\tthrow new TypeError(`toRegexRange: expected the second argument '${max}' to be a number like.`);\n\t}\n\n\tmin = String(min);\n\tmax = String(max);\n\n\tlet opts: IOptions = { relaxZeros: true, ...options };\n\tif (typeof opts.strictZeros === 'boolean')\n\t{\n\t\topts.relaxZeros = opts.strictZeros === false;\n\t}\n\n\tlet relax = String(opts.relaxZeros);\n\tlet shorthand = String(opts.shorthand);\n\tlet capture = String(opts.capture);\n\tlet wrap = String(opts.wrap);\n\tlet cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n\tif (toRegexRange[SymCache].hasOwnProperty(cacheKey))\n\t{\n\t\t// @ts-ignore\n\t\treturn toRegexRange[SymCache][cacheKey].result;\n\t}\n\n\t// @ts-ignore\n\tlet a = Math.min(min, max);\n\t// @ts-ignore\n\tlet b = Math.max(min, max);\n\n\tif (Math.abs(a - b) === 1)\n\t{\n\t\tlet result = min + '|' + max;\n\t\tif (opts.capture)\n\t\t{\n\t\t\treturn `(${result})`;\n\t\t}\n\t\tif (opts.wrap === false)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\treturn `(?:${result})`;\n\t}\n\n\tlet isPadded = hasPadding(min) || hasPadding(max);\n\tlet state: any = { min, max, a, b };\n\tlet positives = [];\n\tlet negatives = [];\n\n\tif (isPadded)\n\t{\n\t\tstate.isPadded = isPadded;\n\t\tstate.maxLen = String(state.max).length;\n\t}\n\n\tif (a < 0)\n\t{\n\t\tlet newMin = b < 0 ? Math.abs(b) : 1;\n\t\tnegatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n\t\ta = state.a = 0;\n\t}\n\n\tif (b >= 0)\n\t{\n\t\tpositives = splitToPatterns(a, b, state, opts);\n\t}\n\n\tstate.negatives = negatives;\n\tstate.positives = positives;\n\tstate.result = collatePatterns(negatives, positives, opts);\n\n\tif (opts.capture === true)\n\t{\n\t\tstate.result = `(${state.result})`;\n\t}\n\telse if (opts.wrap !== false && (positives.length + negatives.length) > 1)\n\t{\n\t\tstate.result = `(?:${state.result})`;\n\t}\n\n\ttoRegexRange[SymCache][cacheKey] = state;\n\treturn state.result;\n}\n\nfunction collatePatterns(neg, pos, options)\n{\n\tlet onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n\tlet onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n\tlet intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n\tlet subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n\treturn subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max)\n{\n\tlet nines = 1;\n\tlet zeros = 1;\n\n\tlet stop = countNines(min, nines);\n\tlet stops: any = new Set([max]);\n\n\twhile (min <= stop && stop <= max)\n\t{\n\t\tstops.add(stop);\n\t\tnines += 1;\n\t\tstop = countNines(min, nines);\n\t}\n\n\tstop = countZeros(max + 1, zeros) - 1;\n\n\twhile (min < stop && stop <= max)\n\t{\n\t\tstops.add(stop);\n\t\tzeros += 1;\n\t\tstop = countZeros(max + 1, zeros) - 1;\n\t}\n\n\tstops = [...stops];\n\tstops.sort(compare);\n\treturn stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options)\n{\n\tif (start === stop)\n\t{\n\t\treturn { pattern: start, count: [], digits: 0 };\n\t}\n\n\tlet zipped = zip(start, stop);\n\tlet digits = zipped.length;\n\tlet pattern = '';\n\tlet count = 0;\n\n\tfor (let i = 0; i < digits; i++)\n\t{\n\t\tlet [startDigit, stopDigit] = zipped[i];\n\n\t\tif (startDigit === stopDigit)\n\t\t{\n\t\t\tpattern += startDigit;\n\n\t\t}\n\t\telse if (startDigit !== '0' || stopDigit !== '9')\n\t\t{\n\t\t\tpattern += toCharacterClass(startDigit, stopDigit, options);\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count)\n\t{\n\t\tpattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n\t}\n\n\treturn { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options)\n{\n\tlet ranges = splitToRanges(min, max) as any as any[];\n\tlet tokens = [];\n\tlet start = min;\n\tlet prev;\n\n\tfor (let i = 0; i < ranges.length; i++)\n\t{\n\t\tlet max = ranges[i];\n\t\tlet obj = rangeToPattern(String(start), String(max), options) as any;\n\t\tlet zeros = '';\n\n\t\tif (!tok.isPadded && prev && prev.pattern === obj.pattern)\n\t\t{\n\t\t\tif (prev.count.length > 1)\n\t\t\t{\n\t\t\t\tprev.count.pop();\n\t\t\t}\n\n\t\t\tprev.count.push(obj.count[0]);\n\t\t\tprev.string = prev.pattern + toQuantifier(prev.count);\n\t\t\tstart = max + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tok.isPadded)\n\t\t{\n\t\t\tzeros = padZeros(max, tok, options);\n\t\t}\n\n\t\tobj.string = zeros + obj.pattern + toQuantifier(obj.count);\n\t\ttokens.push(obj);\n\t\tstart = max + 1;\n\t\tprev = obj;\n\t}\n\n\treturn tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options)\n{\n\tlet result = [];\n\n\tfor (let ele of arr)\n\t{\n\t\tlet { string } = ele;\n\n\t\t// only push if _both_ are negative...\n\t\tif (!intersection && !contains(comparison, 'string', string))\n\t\t{\n\t\t\tresult.push(prefix + string);\n\t\t}\n\n\t\t// or _both_ are positive\n\t\tif (intersection && contains(comparison, 'string', string))\n\t\t{\n\t\t\tresult.push(prefix + string);\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b)\n{\n\tlet arr = [];\n\tfor (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\treturn arr;\n}\n\nfunction compare(a, b)\n{\n\treturn a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val)\n{\n\treturn arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len)\n{\n\treturn Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros)\n{\n\treturn integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits)\n{\n\tlet [start = 0, stop = ''] = digits;\n\tif (stop || start > 1)\n\t{\n\t\treturn `{${start + (stop ? ',' + stop : '')}}`;\n\t}\n\treturn '';\n}\n\nfunction toCharacterClass(a, b, options)\n{\n\treturn `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str)\n{\n\treturn /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options)\n{\n\tif (!tok.isPadded)\n\t{\n\t\treturn value;\n\t}\n\n\tlet diff = Math.abs(tok.maxLen - String(value).length);\n\tlet relax = options.relaxZeros !== false;\n\n\tswitch (diff)\n\t{\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn relax ? '0?' : '0';\n\t\tcase 2:\n\t\t\treturn relax ? '0{0,2}' : '00';\n\t\tdefault:\n\t\t{\n\t\t\treturn relax ? `0{0,${diff}}` : `0{${diff}}`;\n\t\t}\n\t}\n}\n\n/**\n * Cache\n */\n\ntoRegexRange[SymCache] = {};\ntoRegexRange.clearCache = () => (toRegexRange[SymCache] = {});\n\nObject.defineProperty(toRegexRange, 'toRegexRange', { value: toRegexRange });\nObject.defineProperty(toRegexRange, 'default', { value: toRegexRange });\nObject.defineProperty(toRegexRange, 'SymCache', { value: SymCache });\n\n/**\n * Expose `toRegexRange`\n */\nexport default toRegexRange;\n","import { toRegexRange } from './index';\n// @ts-ignore\nexport = toRegexRange\n"],"names":["SymCache","Symbol","for","isAllowedValue","value","isNumber","isUnSafeNumLike","test","toRegexRange","min","max","options","TypeError","String","opts","relaxZeros","strictZeros","cacheKey","shorthand","capture","wrap","hasOwnProperty","result","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","length","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","concat","join","rangeToPattern","start","stop","pattern","count","digits","zipped","zip","arr","i","push","startDigit","stopDigit","tok","prev","ranges","splitToRanges","nines","zeros","countNines","stops","Set","add","countZeros","sort","compare","tokens","obj","padZeros","string","toQuantifier","pop","comparison","prefix","intersection","ele","contains","key","val","some","len","Number","slice","repeat","integer","pow","str","diff","relax","clearCache","Object","defineProperty"],"mappings":"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"}