{"version":3,"file":"index.esm.mjs","sources":["../src/index.ts"],"sourcesContent":["/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nimport { isUnSafeNumLike as isNumber } from '@lazy-assert/check-basic';\n\nexport interface IOptions\n{\n\t/**\n\t * Wrap the returned value in parentheses when there is more than one regex condition. Useful when you're dynamically generating ranges.\n\t *\n\t * @example\n\t * console.log(toRegexRange('-10', '10'));\n\t * //=> -[1-9]|-?10|[0-9]\n\t *\n\t * console.log(toRegexRange('-10', '10', { capture: true }));\n\t * //=> (-[1-9]|-?10|[0-9])\n\t */\n\tcapture?: boolean,\n\t/**\n\t * Use the regex shorthand for [0-9]:\n\t *\n\t * @example\n\t * console.log(toRegexRange('0', '999999'));\n\t * //=> [0-9]|[1-9][0-9]{1,5}\n\t *\n\t * console.log(toRegexRange('0', '999999', { shorthand: true }));\n\t * //=> \\d|[1-9]\\d{1,5}\n\t */\n\tshorthand?: boolean,\n\t/**\n\t * @default true\n\t * This option relaxes matching for leading zeros when when ranges are zero-padded.\n\t * @example\n\t * const source = toRegexRange('-0010', '0010');\n\t * const regex = new RegExp(`^${source}$`);\n\t * console.log(regex.test('-10')); //=> true\n\t * console.log(regex.test('-010')); //=> true\n\t * console.log(regex.test('-0010')); //=> true\n\t * console.log(regex.test('10')); //=> true\n\t * console.log(regex.test('010')); //=> true\n\t * console.log(regex.test('0010')); //=> true\n\t * @example When `relaxZeros` is false, matching is strict:\n\t * const source = toRegexRange('-0010', '0010', { relaxZeros: false });\n\t * const regex = new RegExp(`^${source}$`);\n\t * console.log(regex.test('-10')); //=> false\n\t * console.log(regex.test('-010')); //=> false\n\t * console.log(regex.test('-0010')); //=> true\n\t * console.log(regex.test('10')); //=> false\n\t * console.log(regex.test('010')); //=> false\n\t * console.log(regex.test('0010')); //=> true\n\t */\n\trelaxZeros?: boolean,\n\n\tstrictZeros?: boolean,\n\twrap?: boolean,\n}\n\nexport const SymCache = Symbol.for('SymCache');\n\nfunction isAllowedValue(value: unknown)\n{\n\tif (isNumber(value) === true)\n\t{\n\t\tif (typeof value === 'string')\n\t\t{\n\t\t\treturn /^-?\\d+$/.test(value);\n\t\t}\n\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nexport function toRegexRange(min: number | string, max?: number | string, options?: IOptions): string\n{\n\tif (!isAllowedValue(min))\n\t{\n\t\tthrow new TypeError(`toRegexRange: expected the first argument '${min}' to be a number like.`);\n\t}\n\n\tif (max === void 0 || min === max)\n\t{\n\t\treturn String(min);\n\t}\n\n\tif (!isAllowedValue(max))\n\t{\n\t\tthrow new TypeError(`toRegexRange: expected the second argument '${max}' to be a number like.`);\n\t}\n\n\tmin = String(min);\n\tmax = String(max);\n\n\tlet opts: IOptions = { relaxZeros: true, ...options };\n\tif (typeof opts.strictZeros === 'boolean')\n\t{\n\t\topts.relaxZeros = opts.strictZeros === false;\n\t}\n\n\tlet relax = String(opts.relaxZeros);\n\tlet shorthand = String(opts.shorthand);\n\tlet capture = String(opts.capture);\n\tlet wrap = String(opts.wrap);\n\tlet cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n\tif (toRegexRange[SymCache].hasOwnProperty(cacheKey))\n\t{\n\t\t// @ts-ignore\n\t\treturn toRegexRange[SymCache][cacheKey].result;\n\t}\n\n\t// @ts-ignore\n\tlet a = Math.min(min, max);\n\t// @ts-ignore\n\tlet b = Math.max(min, max);\n\n\tif (Math.abs(a - b) === 1)\n\t{\n\t\tlet result = min + '|' + max;\n\t\tif (opts.capture)\n\t\t{\n\t\t\treturn `(${result})`;\n\t\t}\n\t\tif (opts.wrap === false)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\treturn `(?:${result})`;\n\t}\n\n\tlet isPadded = hasPadding(min) || hasPadding(max);\n\tlet state: any = { min, max, a, b };\n\tlet positives = [];\n\tlet negatives = [];\n\n\tif (isPadded)\n\t{\n\t\tstate.isPadded = isPadded;\n\t\tstate.maxLen = String(state.max).length;\n\t}\n\n\tif (a < 0)\n\t{\n\t\tlet newMin = b < 0 ? Math.abs(b) : 1;\n\t\tnegatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n\t\ta = state.a = 0;\n\t}\n\n\tif (b >= 0)\n\t{\n\t\tpositives = splitToPatterns(a, b, state, opts);\n\t}\n\n\tstate.negatives = negatives;\n\tstate.positives = positives;\n\tstate.result = collatePatterns(negatives, positives, opts);\n\n\tif (opts.capture === true)\n\t{\n\t\tstate.result = `(${state.result})`;\n\t}\n\telse if (opts.wrap !== false && (positives.length + negatives.length) > 1)\n\t{\n\t\tstate.result = `(?:${state.result})`;\n\t}\n\n\ttoRegexRange[SymCache][cacheKey] = state;\n\treturn state.result;\n}\n\nfunction collatePatterns(neg, pos, options)\n{\n\tlet onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n\tlet onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n\tlet intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n\tlet subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n\treturn subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max)\n{\n\tlet nines = 1;\n\tlet zeros = 1;\n\n\tlet stop = countNines(min, nines);\n\tlet stops: any = new Set([max]);\n\n\twhile (min <= stop && stop <= max)\n\t{\n\t\tstops.add(stop);\n\t\tnines += 1;\n\t\tstop = countNines(min, nines);\n\t}\n\n\tstop = countZeros(max + 1, zeros) - 1;\n\n\twhile (min < stop && stop <= max)\n\t{\n\t\tstops.add(stop);\n\t\tzeros += 1;\n\t\tstop = countZeros(max + 1, zeros) - 1;\n\t}\n\n\tstops = [...stops];\n\tstops.sort(compare);\n\treturn stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options)\n{\n\tif (start === stop)\n\t{\n\t\treturn { pattern: start, count: [], digits: 0 };\n\t}\n\n\tlet zipped = zip(start, stop);\n\tlet digits = zipped.length;\n\tlet pattern = '';\n\tlet count = 0;\n\n\tfor (let i = 0; i < digits; i++)\n\t{\n\t\tlet [startDigit, stopDigit] = zipped[i];\n\n\t\tif (startDigit === stopDigit)\n\t\t{\n\t\t\tpattern += startDigit;\n\n\t\t}\n\t\telse if (startDigit !== '0' || stopDigit !== '9')\n\t\t{\n\t\t\tpattern += toCharacterClass(startDigit, stopDigit, options);\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count)\n\t{\n\t\tpattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n\t}\n\n\treturn { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options)\n{\n\tlet ranges = splitToRanges(min, max) as any as any[];\n\tlet tokens = [];\n\tlet start = min;\n\tlet prev;\n\n\tfor (let i = 0; i < ranges.length; i++)\n\t{\n\t\tlet max = ranges[i];\n\t\tlet obj = rangeToPattern(String(start), String(max), options) as any;\n\t\tlet zeros = '';\n\n\t\tif (!tok.isPadded && prev && prev.pattern === obj.pattern)\n\t\t{\n\t\t\tif (prev.count.length > 1)\n\t\t\t{\n\t\t\t\tprev.count.pop();\n\t\t\t}\n\n\t\t\tprev.count.push(obj.count[0]);\n\t\t\tprev.string = prev.pattern + toQuantifier(prev.count);\n\t\t\tstart = max + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tok.isPadded)\n\t\t{\n\t\t\tzeros = padZeros(max, tok, options);\n\t\t}\n\n\t\tobj.string = zeros + obj.pattern + toQuantifier(obj.count);\n\t\ttokens.push(obj);\n\t\tstart = max + 1;\n\t\tprev = obj;\n\t}\n\n\treturn tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options)\n{\n\tlet result = [];\n\n\tfor (let ele of arr)\n\t{\n\t\tlet { string } = ele;\n\n\t\t// only push if _both_ are negative...\n\t\tif (!intersection && !contains(comparison, 'string', string))\n\t\t{\n\t\t\tresult.push(prefix + string);\n\t\t}\n\n\t\t// or _both_ are positive\n\t\tif (intersection && contains(comparison, 'string', string))\n\t\t{\n\t\t\tresult.push(prefix + string);\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b)\n{\n\tlet arr = [];\n\tfor (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\treturn arr;\n}\n\nfunction compare(a, b)\n{\n\treturn a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val)\n{\n\treturn arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len)\n{\n\treturn Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros)\n{\n\treturn integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits)\n{\n\tlet [start = 0, stop = ''] = digits;\n\tif (stop || start > 1)\n\t{\n\t\treturn `{${start + (stop ? ',' + stop : '')}}`;\n\t}\n\treturn '';\n}\n\nfunction toCharacterClass(a, b, options)\n{\n\treturn `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str)\n{\n\treturn /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options)\n{\n\tif (!tok.isPadded)\n\t{\n\t\treturn value;\n\t}\n\n\tlet diff = Math.abs(tok.maxLen - String(value).length);\n\tlet relax = options.relaxZeros !== false;\n\n\tswitch (diff)\n\t{\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn relax ? '0?' : '0';\n\t\tcase 2:\n\t\t\treturn relax ? '0{0,2}' : '00';\n\t\tdefault:\n\t\t{\n\t\t\treturn relax ? `0{0,${diff}}` : `0{${diff}}`;\n\t\t}\n\t}\n}\n\n/**\n * Cache\n */\n\ntoRegexRange[SymCache] = {};\ntoRegexRange.clearCache = () => (toRegexRange[SymCache] = {});\n\nObject.defineProperty(toRegexRange, 'toRegexRange', { value: toRegexRange });\nObject.defineProperty(toRegexRange, 'default', { value: toRegexRange });\nObject.defineProperty(toRegexRange, 'SymCache', { value: SymCache });\n\n/**\n * Expose `toRegexRange`\n */\nexport default toRegexRange;\n"],"names":["SymCache","Symbol","for","isAllowedValue","value","isNumber","test","toRegexRange","min","max","options","TypeError","String","opts","relaxZeros","strictZeros","cacheKey","shorthand","capture","wrap","hasOwnProperty","result","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","length","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","concat","join","rangeToPattern","start","stop","pattern","count","digits","zipped","zip","arr","i","push","startDigit","stopDigit","tok","prev","ranges","splitToRanges","nines","zeros","countNines","stops","Set","add","countZeros","sort","compare","tokens","obj","padZeros","string","toQuantifier","pop","comparison","prefix","intersection","ele","contains","key","val","some","len","Number","slice","repeat","integer","pow","str","diff","relax","clearCache","Object","defineProperty"],"mappings":"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"}