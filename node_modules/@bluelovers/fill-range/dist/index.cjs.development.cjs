'use strict';

var util = require('util');
var toRegexRange2 = require('@bluelovers/to-regex-range2');

var EnumNegative;

(function (EnumNegative) {
  EnumNegative["negative"] = "-";
  EnumNegative["none"] = "";
})(EnumNegative || (EnumNegative = {}));

function isObject(val) {
  return val !== null && typeof val === 'object' && !Array.isArray(val);
}

const transform = toNumber => {
  if (toNumber === true) return value => Number(value);
  return value => String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || typeof value === 'string' && value !== '';
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;

  while (value[++index] === '0');

  return index > 0;
};

const stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }

  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    input = toMaxLen(input, maxLength);
  }

  if (toNumber === false) {
    return String(input);
  }

  return input;
};

const toMaxLen = (input, _maxLength) => {
  let {
    result,
    negative,
    maxLength
  } = _prefixNegative(input, _maxLength);

  return negative + result.padStart(maxLength, '0');
};

function _partsSort(part) {
  part.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
}

function _partsCapturePrefix(options) {
  return options.capture ? '' : '?:';
}

function _prefixNegative(input, maxLength) {
  const negative = input[0] === "-" ? "-" : "";

  if (negative === "-") {
    input = input.slice(1);
    maxLength--;
  }

  return {
    result: input,
    negative,
    maxLength
  };
}

function _join(part) {
  return part.join('|');
}

const toSequence = (parts, options) => {
  _partsSort(parts.negatives);

  _partsSort(parts.positives);

  let prefix = _partsCapturePrefix(options);

  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = _join(parts.positives);
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${_join(parts.negatives)})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange2.toRegexRange(a, b, {
      wrap: false,
      ...options
    });
  }

  const start = String.fromCharCode(a);
  if (a === b) return start;
  const stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    const wrap = options.wrap === true;

    const prefix = _partsCapturePrefix(options);

    start = _join(start);
    return wrap ? `(${prefix}${start})` : start;
  }

  return toRegexRange2.toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end], options);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }

  return [];
};

function _handleLimit(options) {
  return options.limit > 0 ? options.limit : Infinity;
}

function _handleStep(step) {
  return Math.max(Math.abs(step), 1);
}

function _handleOptions(opts, clone) {
  if (clone === true) {
    opts = { ...opts
    };
  }

  if (opts.capture === true) opts.wrap = true;
  return opts;
}

function _handleDescending(start, end, options) {
  const descending = start > end;

  if (descending === true && options.strictOrder) {
    throw rangeError([start, end], options);
  }

  return descending;
}

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end], options);
    return [];
  }

  if (a === 0) a = 0;
  if (b === 0) b = 0;

  const descending = _handleDescending(a, b, options);

  const startString = String(start);
  const endString = String(end);
  const stepString = String(step);
  step = _handleStep(step);
  const padded = zeros(startString) || zeros(endString) || zeros(stepString);
  const maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  const toNumber = padded === false && stringify(start, end, options) === false;
  const format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(String(start), maxLen), toMaxLen(String(end), maxLen), true, options);
  }

  const parts = {
    negatives: [],
    positives: []
  };

  const push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));

  const range = [];
  let index = 0;

  const limit = _handleLimit(options);

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }

    a = descending ? a - step : a + step;
    index++;
    if (index >= limit) break;
  }

  if (options.toRegex === true) {
    return step > 1 ? toSequence(parts, options) : toRegex(range, null, {
      wrap: false,
      ...options
    });
  }

  return range;
};

function fillLetters(start, end, step = 1, options = {}) {
  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
    return invalidRange(start, end, options);
  }

  const format = options.transform || (val => String.fromCharCode(val));

  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  const descending = _handleDescending(a, b, options);

  const min = Math.min(a, b);
  const max = Math.max(a, b);

  if (options.toRegex === true && step === 1) {
    return toRange(min, max, false, options);
  }

  const range = [];
  let index = 0;

  const limit = _handleLimit(options);

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
    if (index >= limit) break;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, {
      wrap: false,
      ...options
    });
  }

  return range;
}

function fill(start, end, step, options = {}) {
  const _s = isValidValue(start);

  if ((typeof end === 'undefined' || end === null) && _s) {
    return [start];
  }

  if (!_s || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    [step, options] = [1, {
      transform: step
    }];
  }

  if (isObject(step)) {
    [step, options] = [0, step];
  }

  let opts = options;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    [step, opts] = [1, opts];
  }

  opts = _handleOptions(opts, true);

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, _handleStep(step), opts);
}
Object.defineProperty(fill, '__esModule', {
  value: true
});
Object.defineProperty(fill, 'fill', {
  value: fill
});
Object.defineProperty(fill, 'default', {
  value: fill
});

module.exports = fill;
//# sourceMappingURL=index.cjs.development.cjs.map
