import { inspect as t } from "util";

import { toRegexRange as e } from "@bluelovers/to-regex-range2";

var r;

function isObject(t) {
  return null !== t && "object" == typeof t && !Array.isArray(t);
}

!function(t) {
  t.negative = "-", t.none = "";
}(r || (r = {}));

const isValidValue = t => "number" == typeof t || "string" == typeof t && "" !== t, isNumber = t => Number.isInteger(+t), zeros = t => {
  let e = `${t}`, r = -1;
  if ("-" === e[0] && (e = e.slice(1)), "0" === e) return !1;
  for (;"0" === e[++r]; ) ;
  return r > 0;
}, pad = (t, e, r) => (e > 0 && (t = toMaxLen(t, e)), !1 === r ? String(t) : t), toMaxLen = (t, e) => {
  let {result: r, negative: n, maxLength: i} = function _prefixNegative(t, e) {
    const r = "-" === t[0] ? "-" : "";
    return "-" === r && (t = t.slice(1), e--), {
      result: t,
      negative: r,
      maxLength: e
    };
  }(t, e);
  return n + r.padStart(i, "0");
};

function _partsSort(t) {
  t.sort(((t, e) => t < e ? -1 : t > e ? 1 : 0));
}

function _partsCapturePrefix(t) {
  return t.capture ? "" : "?:";
}

function _join(t) {
  return t.join("|");
}

const toRange = (t, r, n, i) => {
  if (n) return e(t, r, {
    wrap: !1,
    ...i
  });
  const o = String.fromCharCode(t);
  return t === r ? o : `[${o}-${String.fromCharCode(r)}]`;
}, toRegex = (t, r, n) => {
  if (Array.isArray(t)) {
    const e = !0 === n.wrap, r = _partsCapturePrefix(n);
    return t = _join(t), e ? `(${r}${t})` : t;
  }
  return e(t, r, n);
}, rangeError = (...e) => new RangeError("Invalid range arguments: " + t(...e)), invalidRange = (t, e, r) => {
  if (!0 === r.strictRanges) throw rangeError([ t, e ], r);
  return [];
};

function _handleLimit(t) {
  return t.limit > 0 ? t.limit : Infinity;
}

function _handleStep(t) {
  return Math.max(Math.abs(t), 1);
}

function _handleDescending(t, e, r) {
  const n = t > e;
  if (!0 === n && r.strictOrder) throw rangeError([ t, e ], r);
  return n;
}

function fill(t, e, r, n = {}) {
  const i = isValidValue(t);
  if (null == e && i) return [ t ];
  if (!i || !isValidValue(e)) return invalidRange(t, e, n);
  "function" == typeof r && ([r, n] = [ 1, {
    transform: r
  } ]), isObject(r) && ([r, n] = [ 0, r ]);
  let o = n;
  if (!isNumber(r = r || o.step || 1)) {
    if (null != r && !isObject(r)) return ((t, e) => {
      if (!0 === e.strictRanges) throw new TypeError(`Expected step "${t}" to be a number`);
      return [];
    })(r, o);
    [r, o] = [ 1, o ];
  }
  return o = function _handleOptions(t, e) {
    return !0 === e && (t = {
      ...t
    }), !0 === t.capture && (t.wrap = !0), t;
  }(o, !0), isNumber(t) && isNumber(e) ? ((t, e, r = 1, n = {}) => {
    let i = Number(t), o = Number(e);
    if (!Number.isInteger(i) || !Number.isInteger(o)) {
      if (!0 === n.strictRanges) throw rangeError([ t, e ], n);
      return [];
    }
    0 === i && (i = 0), 0 === o && (o = 0);
    const a = _handleDescending(i, o, n), s = String(t), u = String(e), l = String(r);
    r = _handleStep(r);
    const f = zeros(s) || zeros(u) || zeros(l), g = f ? Math.max(s.length, u.length, l.length) : 0, c = !1 === f && !1 === ((t, e, r) => "string" == typeof t || "string" == typeof e || !0 === r.stringify)(t, e, n), p = n.transform || (t => !0 === t ? t => Number(t) : t => String(t))(c);
    if (n.toRegex && 1 === r) return toRange(toMaxLen(String(t), g), toMaxLen(String(e), g), !0, n);
    const h = {
      negatives: [],
      positives: []
    }, m = [];
    let d = 0;
    const _ = _handleLimit(n);
    for (;(a ? i >= o : i <= o) && (!0 === n.toRegex && r > 1 ? h[(v = i) < 0 ? "negatives" : "positives"].push(Math.abs(v)) : m.push(pad(p(i, d), g, c)), 
    i = a ? i - r : i + r, d++, !(d >= _)); ) ;
    var v;
    return !0 === n.toRegex ? r > 1 ? ((t, e) => {
      _partsSort(t.negatives), _partsSort(t.positives);
      let r, n = _partsCapturePrefix(e), i = "", o = "";
      return t.positives.length && (i = _join(t.positives)), t.negatives.length && (o = `-(${n}${_join(t.negatives)})`), 
      r = i && o ? `${i}|${o}` : i || o, e.wrap ? `(${n}${r})` : r;
    })(h, n) : toRegex(m, null, {
      wrap: !1,
      ...n
    }) : m;
  })(t, e, r, o) : function fillLetters(t, e, r = 1, n = {}) {
    if (!isNumber(t) && t.length > 1 || !isNumber(e) && e.length > 1) return invalidRange(t, e, n);
    const i = n.transform || (t => String.fromCharCode(t));
    let o = `${t}`.charCodeAt(0), a = `${e}`.charCodeAt(0);
    const s = _handleDescending(o, a, n), u = Math.min(o, a), l = Math.max(o, a);
    if (!0 === n.toRegex && 1 === r) return toRange(u, l, !1, n);
    const f = [];
    let g = 0;
    const c = _handleLimit(n);
    for (;(s ? o >= a : o <= a) && (f.push(i(o, g)), o = s ? o - r : o + r, g++, !(g >= c)); ) ;
    return !0 === n.toRegex ? toRegex(f, null, {
      wrap: !1,
      ...n
    }) : f;
  }(t, e, _handleStep(r), o);
}

Object.defineProperty(fill, "__esModule", {
  value: !0
}), Object.defineProperty(fill, "fill", {
  value: fill
}), Object.defineProperty(fill, "default", {
  value: fill
});

export { fill as default, fill };
//# sourceMappingURL=index.esm.mjs.map
